[{"title":"博客更新说明","date":"2023-02-06T16:00:00.000Z","path":"2023/Deploy/博客更新说明/","text":"博客最近整合到了notion统一管理，并更新了hexo和主题版本，正在逐个完善并重新上传之前的博客内容","tags":[{"name":"部署","slug":"部署","permalink":"https://www.delta1037.cn/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"hexo 新增mermaid支持","date":"2023-02-06T16:00:00.000Z","path":"2023/Deploy/hexo新增mermaid支持/","text":"趁着博客整合，修理一下mermaid不支持的问题。 从网上找到了一些教程，但是配置过程中也发现了一些问题，所以在这里记录一下。 一、安装安装插件： 1npm install hexo-filter-mermaid-diagrams 添加配置。在主题目录下的_config.yml文件中新增配置： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 添加支持。我使用的BuleLake主题js后缀是.ejs（其它类型（.pug、.swig）参考Github说明），在themes\\bluelake\\layout\\_partial\\**after-footer.ejs**中添加如下内容 12345678&lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; 二、使用主题类型：（在上面修改文件时配置）： default - This is the default theme for all diagrams. neutral - This theme is great for black and white documents that will be printed. dark - This theme goes well with dark-colored elements or dark-mode. forest - This theme contains shades of green. base - This is the only theme that can be modified. Use this theme as the base for customizations. 三、注意 mermaid新增配置是修改的主题目录下的文件 需要将根目录配置_config.yml中highlight下的auto_detect设置为true","tags":[{"name":"部署","slug":"部署","permalink":"https://www.delta1037.cn/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"Latex fontspec Error","date":"2023-02-05T16:00:00.000Z","path":"2023/Bugsfix/LatexfontspecError/","text":"latex编译时，出现报错! Package fontspec Error: The font &quot;Microsoft YaHei&quot; cannot be found. 排查问题记录与问题的思考。 一、环境 window11 texlive 2022 一份带有中文的tex文件 12# 中文环境配置\\usepackage[UTF8]&#123;ctex&#125; 二、问题在执行xelatex *.tex时，出现如下报错： 12345678910111213141516171819202122Package biblatex Warning: &#x27;babel/polyglossia&#x27; detected but &#x27;csquotes&#x27; missing.(biblatex) Loading &#x27;csquotes&#x27; recommended.(e:/texlive/2022/texmf-dist/tex/latex/newpx/TeXGyrePagellaX.fontspec)(./main.aux)*geometry* driver: auto-detecting*geometry* detected driver: xetex(e:/texlive/2022/texmf-dist/tex/latex/biblatex/lbx/english.lbx)No file main.bbl.Package hyperref Warning: Rerun to get /PageLabels entry.! Package fontspec Error: The font &quot;Microsoft YaHei&quot; cannot be found.For immediate help type H &lt;return&gt;. ...l.79 ...sep=1cm]&#123;\\Huge\\centering\\bfseries\\sffamily \\parbox[c][][t]&#123;\\paperwidt...? 已知该字体已安装（解决过程中也重装该字体很多次） 三、解决看到! Package fontspec Error: The font &quot;Microsoft YaHei&quot; cannot be found时，判断为字体没有识别，于是尝试重装该字体，重新加载字体缓存等操作，均无效（搞了一下午的字体问题，还把window10上的字体拷贝过来重新安装了）。 恰好手边有另一份带有中文的tex源文件（并不知道其中是如何配置的中文环境，只是有试一试的想法），于是尝试编译，结果成功了。 那么报字体问题的错误，问题根源是否出在字体问题上呢？再回顾模板的下载和修改过程，发现有一段数学符号包是后来添加的： 123456\\usepackage&#123;esint&#125;\\newcommand&#123;\\gt&#125;&#123;\\textgreater&#125;\\newcommand&#123;\\lt&#125;&#123;\\textless&#125;\\usepackage&#123;euler&#125;\\usepackage&#123;newpxtext&#125;\\usepackage&#123;amsmath&#125; 使用排除法（将上面所有的包全注释掉，一个一个添加），发现是newpxtext的问题，去掉该包之后，执行xelatex *.tex时，没有再出现报错。 四、思考虽然终端显示的是字体问题，但是当字体确实没有问题的时候，就要考虑别的方向，做一些并行测试来对比分析（例如上面在另外一份类似的tex工程中尝试编译）。 另外要仔细分析日志，再看日志最后一部分时，可以看到有以下疑点： 123456789101112131415161718192021222324252627(e:/texlive/2022/texmf-dist/tex/latex/realscripts/realscripts.sty))Package biblatex Warning: &#x27;babel/polyglossia&#x27; detected but &#x27;csquotes&#x27; missing.(biblatex) Loading &#x27;csquotes&#x27; recommended.# 1、这里出现的最后的包是newpx，就是newpxtext(e:/texlive/2022/texmf-dist/tex/latex/&lt;font color=&quot;#D44C47&quot;&gt;**newpx**&lt;/font&gt;/TeXGyrePagellaX.fontspec)# 2、这里来看，有几个包含中文的文件都已经通过了，所以有可能不是字体问题&lt;font color=&quot;#D44C47&quot;&gt;(./main.aux (./sub_chapter/01-basic_block.aux)(./sub_chapter/02-advance_block.aux) (./sub_chapter/03-database.aux)(./sub_chapter/04-multi_media.aux) (./sub_chapter/05-insert_block.aux)(./sub_chapter/06-rich_text.aux) (./sub_chapter/07-database_op.aux)(./sub_chapter/08-database_formula.aux))&lt;/font&gt;*geometry* driver: auto-detecting*geometry* detected driver: xetex(e:/texlive/2022/texmf-dist/tex/latex/biblatex/lbx/english.lbx)No file main.bbl.! Package fontspec Error: The font &quot;Microsoft YaHei&quot; cannot be found.For immediate help type H &lt;return&gt;. ...l.79 ...sep=1cm]&#123;\\Huge\\centering\\bfseries\\sffamily \\parbox[c][][t]&#123;\\paperwidt...? 完整的输出日志： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277PS F:\\GitHubRepo\\LatexBook\\Notion_handout_latex&gt; xelatex mainThis is XeTeX, Version 3.141592653-2.6-0.999994 (TeX Live 2022) (preloaded format=xelatex) restricted \\write18 enabled.entering extended mode(./main.texLaTeX2e &lt;2022-11-01&gt; patch level 1L3 programming layer &lt;2023-02-02&gt;(e:/texlive/2022/texmf-dist/tex/latex/base/book.clsDocument Class: book 2022/07/02 v1.4n Standard LaTeX document class(e:/texlive/2022/texmf-dist/tex/latex/base/fleqn.clo)(e:/texlive/2022/texmf-dist/tex/latex/base/bk11.clo)) (./structure.tex(e:/texlive/2022/texmf-dist/tex/latex/graphics/graphicx.sty(e:/texlive/2022/texmf-dist/tex/latex/graphics/keyval.sty)(e:/texlive/2022/texmf-dist/tex/latex/graphics/graphics.sty(e:/texlive/2022/texmf-dist/tex/latex/graphics/trig.sty)(e:/texlive/2022/texmf-dist/tex/latex/graphics-cfg/graphics.cfg)(e:/texlive/2022/texmf-dist/tex/latex/graphics-def/xetex.def)))(e:/texlive/2022/texmf-dist/tex/latex/lipsum/lipsum.sty(e:/texlive/2022/texmf-dist/tex/latex/l3packages/l3keys2e/l3keys2e.sty(e:/texlive/2022/texmf-dist/tex/latex/l3kernel/expl3.sty(e:/texlive/2022/texmf-dist/tex/latex/l3backend/l3backend-xetex.def)))(e:/texlive/2022/texmf-dist/tex/latex/lipsum/lipsum.ltd.tex))(e:/texlive/2022/texmf-dist/tex/latex/pgf/frontendlayer/tikz.sty(e:/texlive/2022/texmf-dist/tex/latex/pgf/basiclayer/pgf.sty(e:/texlive/2022/texmf-dist/tex/latex/pgf/utilities/pgfrcs.sty(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgfutil-common.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgfutil-latex.def)(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgfrcs.code.tex(e:/texlive/2022/texmf-dist/tex/generic/pgf/pgf.revision.tex)))(e:/texlive/2022/texmf-dist/tex/latex/pgf/basiclayer/pgfcore.sty(e:/texlive/2022/texmf-dist/tex/latex/pgf/systemlayer/pgfsys.sty(e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgfsys.code.tex(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgfkeys.code.tex(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgfkeyslibraryfiltered.code.tex)) (e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgf.cfg)(e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgfsys-xetex.def(e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgfsys-dvipdfmx.def(e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgfsys-common-pdf.def))))(e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgfsyssoftpath.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/systemlayer/pgfsysprotocol.code.tex)) (e:/texlive/2022/texmf-dist/tex/latex/xcolor/xcolor.sty(e:/texlive/2022/texmf-dist/tex/latex/graphics-cfg/color.cfg)(e:/texlive/2022/texmf-dist/tex/latex/graphics/mathcolor.ltx))(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcore.code.tex(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmath.code.tex(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathutil.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathparser.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.basic.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.trigonometric.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.random.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.comparison.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.base.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.round.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.misc.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfunctions.integerarithmetics.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathcalc.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmathfloat.code.tex))(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfint.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorepoints.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorepathconstruct.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorepathusage.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorescopes.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoregraphicstate.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoretransformations.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorequick.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoreobjects.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorepathprocessing.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorearrows.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoreshade.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoreimage.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoreexternal.code.tex) (e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorelayers.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcoretransparency.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorepatterns.code.tex) (e:/texlive/2022/texmf-dist/tex/generic/pgf/basiclayer/pgfcorerdf.code.tex))) (e:/texlive/2022/texmf-dist/tex/generic/pgf/modules/pgfmoduleshapes.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/modules/pgfmoduleplot.code.tex)(e:/texlive/2022/texmf-dist/tex/latex/pgf/compatibility/pgfcomp-version-0-65.sty)(e:/texlive/2022/texmf-dist/tex/latex/pgf/compatibility/pgfcomp-version-1-18.sty)) (e:/texlive/2022/texmf-dist/tex/latex/pgf/utilities/pgffor.sty(e:/texlive/2022/texmf-dist/tex/latex/pgf/utilities/pgfkeys.sty(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgfkeys.code.tex))(e:/texlive/2022/texmf-dist/tex/latex/pgf/math/pgfmath.sty(e:/texlive/2022/texmf-dist/tex/generic/pgf/math/pgfmath.code.tex))(e:/texlive/2022/texmf-dist/tex/generic/pgf/utilities/pgffor.code.tex))(e:/texlive/2022/texmf-dist/tex/generic/pgf/frontendlayer/tikz/tikz.code.tex(e:/texlive/2022/texmf-dist/tex/generic/pgf/libraries/pgflibraryplothandlers.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/modules/pgfmodulematrix.code.tex)(e:/texlive/2022/texmf-dist/tex/generic/pgf/frontendlayer/tikz/libraries/tikzlibrarytopaths.code.tex)))(e:/texlive/2022/texmf-dist/tex/generic/babel/babel.sty(e:/texlive/2022/texmf-dist/tex/generic/babel/xebabel.def)(e:/texlive/2022/texmf-dist/tex/generic/babel-english/english.ldf))(e:/texlive/2022/texmf-dist/tex/generic/babel/locale/en/babel-english.tex)(e:/texlive/2022/texmf-dist/tex/latex/enumitem/enumitem.sty)(e:/texlive/2022/texmf-dist/tex/latex/booktabs/booktabs.sty)(e:/texlive/2022/texmf-dist/tex/latex/geometry/geometry.sty(e:/texlive/2022/texmf-dist/tex/generic/iftex/ifvtex.sty(e:/texlive/2022/texmf-dist/tex/generic/iftex/iftex.sty)))(e:/texlive/2022/texmf-dist/tex/latex/psnfss/avant.sty)(e:/texlive/2022/texmf-dist/tex/latex/psnfss/mathptmx.sty)(e:/texlive/2022/texmf-dist/tex/latex/microtype/microtype.sty(e:/texlive/2022/texmf-dist/tex/latex/etoolbox/etoolbox.sty)(e:/texlive/2022/texmf-dist/tex/latex/microtype/microtype-xetex.def)(e:/texlive/2022/texmf-dist/tex/latex/microtype/microtype.cfg))(e:/texlive/2022/texmf-dist/tex/latex/base/inputenc.styPackage inputenc Warning: inputenc package ignored with utf8 based engines.) (e:/texlive/2022/texmf-dist/tex/latex/base/fontenc.sty(e:/texlive/2022/texmf-dist/tex/latex/psnfss/t1ptm.fd))(e:/texlive/2022/texmf-dist/tex/latex/biblatex/biblatex.sty(e:/texlive/2022/texmf-dist/tex/generic/pdftexcmds/pdftexcmds.sty(e:/texlive/2022/texmf-dist/tex/generic/infwarerr/infwarerr.sty)(e:/texlive/2022/texmf-dist/tex/generic/ltxcmds/ltxcmds.sty))(e:/texlive/2022/texmf-dist/tex/latex/kvoptions/kvoptions.sty(e:/texlive/2022/texmf-dist/tex/latex/kvsetkeys/kvsetkeys.sty))(e:/texlive/2022/texmf-dist/tex/latex/logreq/logreq.sty(e:/texlive/2022/texmf-dist/tex/latex/logreq/logreq.def))(e:/texlive/2022/texmf-dist/tex/latex/base/ifthen.sty)(e:/texlive/2022/texmf-dist/tex/latex/url/url.sty)(e:/texlive/2022/texmf-dist/tex/latex/biblatex/blx-dm.def)(e:/texlive/2022/texmf-dist/tex/latex/biblatex/blx-unicode.def)(e:/texlive/2022/texmf-dist/tex/latex/biblatex/blx-compat.def)(e:/texlive/2022/texmf-dist/tex/latex/biblatex/biblatex.def)(e:/texlive/2022/texmf-dist/tex/latex/biblatex/bbx/numeric.bbx(e:/texlive/2022/texmf-dist/tex/latex/biblatex/bbx/standard.bbx))(e:/texlive/2022/texmf-dist/tex/latex/biblatex/cbx/numeric.cbx)(e:/texlive/2022/texmf-dist/tex/latex/biblatex/biblatex.cfg)Package biblatex Warning: &#x27;babel&#x27; option is deprecated.(biblatex) Please use &#x27;autolang&#x27; instead.(e:/texlive/2022/texmf-dist/tex/latex/biblatex/blx-case-expl3.sty(e:/texlive/2022/texmf-dist/tex/latex/l3packages/xparse/xparse.sty)))(e:/texlive/2022/texmf-dist/tex/latex/tools/calc.sty)(e:/texlive/2022/texmf-dist/tex/latex/base/makeidx.sty)Writing index file main.idx(e:/texlive/2022/texmf-dist/tex/latex/titlesec/titletoc.sty)(e:/texlive/2022/texmf-dist/tex/latex/fancyhdr/fancyhdr.sty)(e:/texlive/2022/texmf-dist/tex/latex/amsmath/amsmath.styFor additional information on amsmath, use the `?&#x27; option.(e:/texlive/2022/texmf-dist/tex/latex/amsmath/amstext.sty(e:/texlive/2022/texmf-dist/tex/latex/amsmath/amsgen.sty))(e:/texlive/2022/texmf-dist/tex/latex/amsmath/amsbsy.sty)(e:/texlive/2022/texmf-dist/tex/latex/amsmath/amsopn.sty))(e:/texlive/2022/texmf-dist/tex/latex/amsfonts/amsfonts.sty)(e:/texlive/2022/texmf-dist/tex/latex/amsfonts/amssymb.sty)(e:/texlive/2022/texmf-dist/tex/latex/amscls/amsthm.sty)(e:/texlive/2022/texmf-dist/tex/latex/mdframed/mdframed.sty(e:/texlive/2022/texmf-dist/tex/latex/zref/zref-abspage.sty(e:/texlive/2022/texmf-dist/tex/latex/zref/zref-base.sty(e:/texlive/2022/texmf-dist/tex/generic/kvdefinekeys/kvdefinekeys.sty)(e:/texlive/2022/texmf-dist/tex/generic/etexcmds/etexcmds.sty)(e:/texlive/2022/texmf-dist/tex/latex/auxhook/auxhook.sty))(e:/texlive/2022/texmf-dist/tex/latex/base/atbegshi-ltx.sty))(e:/texlive/2022/texmf-dist/tex/latex/needspace/needspace.sty)(e:/texlive/2022/texmf-dist/tex/latex/mdframed/md-frame-0.mdf))(e:/texlive/2022/texmf-dist/tex/latex/hyperref/hyperref.sty(e:/texlive/2022/texmf-dist/tex/generic/pdfescape/pdfescape.sty)(e:/texlive/2022/texmf-dist/tex/latex/hycolor/hycolor.sty)(e:/texlive/2022/texmf-dist/tex/latex/letltxmacro/letltxmacro.sty)(e:/texlive/2022/texmf-dist/tex/latex/hyperref/nameref.sty(e:/texlive/2022/texmf-dist/tex/latex/refcount/refcount.sty)(e:/texlive/2022/texmf-dist/tex/generic/gettitlestring/gettitlestring.sty))(e:/texlive/2022/texmf-dist/tex/latex/hyperref/pd1enc.def)(e:/texlive/2022/texmf-dist/tex/generic/intcalc/intcalc.sty)(e:/texlive/2022/texmf-dist/tex/latex/hyperref/puenc.def)(e:/texlive/2022/texmf-dist/tex/generic/bitset/bitset.sty(e:/texlive/2022/texmf-dist/tex/generic/bigintcalc/bigintcalc.sty)))(e:/texlive/2022/texmf-dist/tex/latex/hyperref/hxetex.def(e:/texlive/2022/texmf-dist/tex/generic/stringenc/stringenc.sty)(e:/texlive/2022/texmf-dist/tex/latex/rerunfilecheck/rerunfilecheck.sty(e:/texlive/2022/texmf-dist/tex/latex/base/atveryend-ltx.sty)(e:/texlive/2022/texmf-dist/tex/generic/uniquecounter/uniquecounter.sty)))Package hyperref Warning: Option `backref&#x27; has already been used,(hyperref) setting the option has no effect on input line 504.Package hyperref Warning: Option `pagebackref&#x27; has already been used,(hyperref) setting the option has no effect on input line 504.Package hyperref Warning: Option `hyperindex&#x27; has already been used,(hyperref) setting the option has no effect on input line 504.Package hyperref Warning: Option `bookmarks&#x27; has already been used,(hyperref) setting the option has no effect on input line 504.(e:/texlive/2022/texmf-dist/tex/latex/bookmark/bookmark.sty(e:/texlive/2022/texmf-dist/tex/latex/bookmark/bkm-dvipdfm.def)))(e:/texlive/2022/texmf-dist/tex/latex/ctex/ctex.sty(e:/texlive/2022/texmf-dist/tex/latex/ctex/ctexhook.sty)(e:/texlive/2022/texmf-dist/tex/latex/ctex/ctexpatch.sty)(e:/texlive/2022/texmf-dist/tex/latex/base/fix-cm.sty(e:/texlive/2022/texmf-dist/tex/latex/base/ts1enc.def))(e:/texlive/2022/texmf-dist/tex/latex/ctex/config/ctexopts.cfg)(e:/texlive/2022/texmf-dist/tex/latex/ctex/engine/ctex-engine-xetex.def(e:/texlive/2022/texmf-dist/tex/xelatex/xecjk/xeCJK.sty(e:/texlive/2022/texmf-dist/tex/latex/l3packages/xtemplate/xtemplate.sty)(e:/texlive/2022/texmf-dist/tex/latex/fontspec/fontspec.sty(e:/texlive/2022/texmf-dist/tex/latex/fontspec/fontspec-xetex.sty(e:/texlive/2022/texmf-dist/tex/latex/base/fontenc.sty)(e:/texlive/2022/texmf-dist/tex/latex/fontspec/fontspec.cfg)))(e:/texlive/2022/texmf-dist/tex/xelatex/xecjk/xeCJK.cfg)))(e:/texlive/2022/texmf-dist/tex/latex/zhnumber/zhnumber.sty(e:/texlive/2022/texmf-dist/tex/latex/zhnumber/zhnumber-utf8.cfg))(e:/texlive/2022/texmf-dist/tex/latex/ctex/scheme/ctex-scheme-chinese.def(e:/texlive/2022/texmf-dist/tex/latex/ctex/config/ctex-name-utf8.cfg))(e:/texlive/2022/texmf-dist/tex/latex/tools/indentfirst.sty)(e:/texlive/2022/texmf-dist/tex/latex/ctex/fontset/ctex-fontset-windows.def))(e:/texlive/2022/texmf-dist/tex/latex/ctex/config/ctex.cfg)(e:/texlive/2022/texmf-dist/tex/latex/esint/esint.sty)(e:/texlive/2022/texmf-dist/tex/latex/euler/euler.styPackage: `euler&#x27; v2.5 &lt;1995/03/05&gt; (FJ and FMi)) (e:/texlive/2022/texmf-dist/tex/latex/newpx/newpxtext.sty`newpxtext&#x27; v1.504, 2022/01/30 Text macros taking advantage of TeXGyre Pagellaand its extensions (msharpe)(e:/texlive/2022/texmf-dist/tex/latex/base/fontenc.sty(e:/texlive/2022/texmf-dist/tex/latex/lm/t1lmr.fd))(e:/texlive/2022/texmf-dist/tex/generic/iftex/ifxetex.sty)(e:/texlive/2022/texmf-dist/tex/generic/iftex/ifluatex.sty)(e:/texlive/2022/texmf-dist/tex/latex/xkeyval/xkeyval.sty(e:/texlive/2022/texmf-dist/tex/generic/xkeyval/xkeyval.tex(e:/texlive/2022/texmf-dist/tex/generic/xkeyval/xkvutils.tex)))(e:/texlive/2022/texmf-dist/tex/latex/base/textcomp.sty)(e:/texlive/2022/texmf-dist/tex/generic/xstring/xstring.sty(e:/texlive/2022/texmf-dist/tex/generic/xstring/xstring.tex))(e:/texlive/2022/texmf-dist/tex/latex/carlisle/scalefnt.sty)(e:/texlive/2022/texmf-dist/tex/latex/realscripts/realscripts.sty))Package biblatex Warning: &#x27;babel/polyglossia&#x27; detected but &#x27;csquotes&#x27; missing.(biblatex) Loading &#x27;csquotes&#x27; recommended.(e:/texlive/2022/texmf-dist/tex/latex/newpx/TeXGyrePagellaX.fontspec)(./main.aux (./sub_chapter/01-basic_block.aux)(./sub_chapter/02-advance_block.aux) (./sub_chapter/03-database.aux)(./sub_chapter/04-multi_media.aux) (./sub_chapter/05-insert_block.aux)(./sub_chapter/06-rich_text.aux) (./sub_chapter/07-database_op.aux)(./sub_chapter/08-database_formula.aux))*geometry* driver: auto-detecting*geometry* detected driver: xetex(e:/texlive/2022/texmf-dist/tex/latex/biblatex/lbx/english.lbx)No file main.bbl.! Package fontspec Error: The font &quot;Microsoft YaHei&quot; cannot be found.For immediate help type H &lt;return&gt;. ...l.79 ...sep=1cm]&#123;\\Huge\\centering\\bfseries\\sffamily \\parbox[c][][t]&#123;\\paperwidt...?","tags":[{"name":"Latex","slug":"Latex","permalink":"https://www.delta1037.cn/tags/Latex/"},{"name":"Bug","slug":"Bug","permalink":"https://www.delta1037.cn/tags/Bug/"}]},{"title":"应用程序设计","date":"2022-03-04T16:00:00.000Z","path":"2022/Project/应用程序设计/","text":"三年工作经验之成果，简要概述了应用程序的设计过程~以下没有参考任何文档，纯属瞎编！ 一、模块划分模块是为了让大型应用程序的结构更加清晰，在对程序进行重构或者修改模块的功能时更加方便。模块一般需要根据功能类型区分，一般功能包括以下几种： 日志记录：用于程序运行过程的打点记录，在程序运行出错时能够定位到出错位置和相关必要数据 DEBUG日志：调试时使用，包括详细的调试信息，程序出错时辅助调试 INFO日志：记录程序运行记录，打卡记录 ERROR日志：记录程序出错记录 数据记录：程序相关的大量数据条目记录，一般与数据库接壤 配置记录：程序配置相关，配置参数则使用文本文件记录（JSON格式、YAML格式等） 会话控制：网络连接模块，用于控制两个程序之间的通信 会话协议：两个程序的会话需要制定明确的会话协议 任务控制：多线程程序 任务启动、停止、回收控制 卡死线程处理 缓存控制：缓存文件数据或者网络数据（辅助快速加载） 1.1 日志记录对于一个日志记录模块，最主要的功能就是提供日志记录功能。其它功能如下： 日志的输出等级：可以选择日志输出的最低等级（低于此等级的日志不输出） 日志输出位置：可以输出到终端、保存到文件。 日志保存到文件时，对于不同模块的日志可以选择保存到到不同的文件；当文件过大时，将日志内容归档管理。 1.2 数据记录在对接到应用程序的上层部分，一般需要根据程序的具体需求定制（比如存储什么数据，许需要哪些数据操作接口（增删查改之类的））。在数据记录的底层部分，可以支持多种数据库类型，方便数据库的切换，或者使用不同的数据库完成不同的需求（瞎猜的，实际没有遇到过）。 该模块可以设计为细腰型结构，包括上层对接具体需求，中层管理，底层聚合多种数据库类型。这种结构一方面是便于新增新的功能或者支持新的数据库；另一方面是方便移植到另一个应用程序上（只需要替换上层部分即可）。细腰型结构示例： graph TD A(数据需求1) --> B(管理) C(数据需求2) --> B(管理) B(管理) --> D[Mysql] B(管理) --> E[SQLITE] 1.3 配置记录配置模块和日志模块一样，都是应用程序的基础。配置用来初始化一些应用程序的参数，如果把这些参数写入到程序内部，那么在需要调整参数的时候就会很麻烦（重新编译程序），所以需要与应用程序隔离的文件来存储一些在程序启动时可能会发生改变的内容。 配置模块需要对应用程序提供的基本功能是根据key来获取对应的值，即获取某个参数的值；配置模块也可以添加一些高级功能，例如向配置文件写入一个参数的值；当程序运行时，如果监测到配置发生改变时，对程序中对应的参数重新初始化。 配置的存储需要与应用程序的语言相适应。C&#x2F;C++一般使用一行即为一个参数配置（使用“：”或者“&#x3D;”隔离参数的key和value）；Python可以很方便的使用json库，所以可以使用JSON文件作为配置文件。 1.4 会话控制会话控制模块一般用于本地或者网络上的两个进程间的通信。通信则一般分为同步和异步方式，同步通信方式就是进程A向进程B索要数据，A等着B完成，然后拿到数据；异步方式是进程A向进程B索要数据，确定B收到索要数据之后A立即返回，B开始准备数据，当B数据准备好之后将数据发送给A，A拿到数据。 会话控制模块一般分为两层，上层是会话协议层，下层是网络传输层，会话协议层主要定义两个程序之间的通信协议（A：你今天吃什么？B：我吃番茄炒鸡蛋），网络传输部分主要是定义信息传输的方式（怎么把”你今天吃什么？“这句话发出去），一般有Socket（TCP&#x2F;UDP）、HTTP等。 graph TD subgraph 从 E(从:会话协议) C(从:网络传输) end subgraph 主 A(主:会话协议) B(主:网络传输) end 1.5 任务控制一般的多任务程序中都需要任务管理，多任务即为多线程任务，多线程任务包括临时任务、持久化任务等等。任务控制模块可以提供任务控制功能，基本的包括启动任务和终止任务，更复杂点的包括任务的活性监测（监测线程是否卡住）。 多任务模块需要考虑的点有： 基本功能： 启动任务：开启一个新的线程，此时需要数据传入和函数传入（不同的类型其处理函数也不一样，处理函数也需要不同的数据，需要考虑的是怎么把开启新线程的接口统一：封装统一的数据结构相对来说是一种扩展性很强的方案） 终止任务：当任务没有分离时，使用的计算机语言一般会提供回收的方式 活性监测：任务开启时注册一个定时器，当定时器结束时说明任务还没有退出（如果进程提前退出则说明该任务实例已经被销毁（注意销毁任务实例的定时器处理）） 1.6 缓存控制缓存控制的目的是存储一些临时性的数据，用来保存数据或者加速访问某些内容。一般应用是可以缓存其它模块的数据内容（比如会话控制的会话数据和任务控制的任务数据）或者需要加速访问的内容（从文件中读取的一些内容、从网络上获取到的内容，这些内容如果重新获取对于一个对运行时间有要求的程序来说时间成本过大。但是要注意，这些内容短期内不会发生变化，如果这些内容每次获取都不一样，那么或许重新获取是无法避免的） 缓存控制的设计比较灵活，一般需要根据实际的应用程序设计（具体问题具体分析）。对于一些常规性的存储内容（其它模块需要存储的数据）则可以统一实现，减少重复造轮子的可能性。 二、逻辑2.1 必要逻辑计算机语言都会（所有的）包含一些必要的逻辑，包括： 数据操作：保存数据、打印数据 顺序执行：逐条执行代码 循环处理：循环执行某段代码 条件处理：根据条件判断是否执行某段代码 函数封装：将某一个小功能封装成函数 2.2 类的概念继承和多态（待补充） 对于含有类概念的计算机语言（C++、Python）： 类的概念比函数封装更进一步。函数封装只会封装单个的功能；类则封装了数据和多个功能，即包含了数据和处理数据的方法。类的一个实例通常称为对象（类可以描述为实例的蓝图，设计图），对象的出现使得类区别于数据和方法的集合。每一个类的对象都有自己的数据空间，使得不同的对象互相隔离。 模块的出现使得同类型的操作得以聚合。例如一个SQLITE数据库操作类，其中数据区域可以包括数据库的位置信息；操作方法包括增删查改等常用方法的集合。 将操作方法聚合成类和聚合成文件（无类）的区别。将操作方法封装成类时，数据定义保存在类中，方法定义保存在类中，当我们操作不同位置的数据库时，可以实例化多个对象，这些对象的区别仅有其中的数据区域（数据库的位置）；将操作方法汇聚成文件时，当我们操作不同位置的数据库时，可以定义空间来存储不同的数据库位置，当调用某一个数据库方法时，需要传入一些必要的内容（例如数据库的位置或者数据库操作句柄）等。 使用类的优势：类将数据定义和方法定义封装到一起，第一是类的进一步封装使得代码边界更加清晰，数据定义易于管理；第二是减少了不必要的外部数据的传入（类初始化时传入并在数据区域统一管理）。 2.3 模块的概念对于含有模块概念的计算机语言： 模块的概念比类的概念更宽泛，类是一种类型（奔驰）的方法的封装，模块可以认为是一类对象（奔驰、奥迪）的封装，实际上模块的分类包括日志记录模块，数据记录模块（里面可能包含了Mysql数据库操作对象和SQLITE数据库操作对象等多种类封装）。 模块的优势：模块将同一属性的内容封装（放）到一起，第一是方便不同模块的管理，方便模块替换（只要对外的API是不改变的，那么模块很容易被替换或者修改内部功能），便于代码的维护（在修改某一部分的功能时，直接到对应的模块修改）； 三、细节计算机语言只是实现目的的一种工具，不同的语言在对模块的实现上有不同的优势，在选用语言来完成某一功能时，需要考虑如下内容： 功能复杂性： 是否需要拆分成不同模块，模块之间的耦合 运行的平台： 运行环境的配置 运行速度要求：编译语言和脚本语言 时间控制精度要求：我之前用Shell写一个程序时，程序的时间很难控制（定时运行） 底层模块依赖：是否有精力进行从砖头开始垒房子，或者快速从墙片开始垒房子（一样结实的） 语言 优势 弱势 平台 分类 C 1、快 1、数据管理2、打地基 1、编译运行 高级 C++ 1、快 1、打地基 1、编译运行 高级 Python 1、库多 1、较慢（边解释边运行） 1、打包运行2、解释器运行 脚本 Shell 1、无需编译 1、数据管理2、复杂处理 1、解释器运行（Linux） 脚本 四、语言组合不同的语言是可以互通的，这样可以解决某一个语言的缺陷。例如Python调用C实现的动态库（以解决Python运行慢的问题）（实例：Numpy底层使用C语言编写，内部解除了GIL（全局解释器锁），其对数组的操作速度不受Python解释器的限制，效率远高于纯Python代码）。 其它代码互相调用的例子不再赘述。 五、程序设计在需求定义完成之后，就可以开始着手程序的架构设计，架构是语言无关的，最终无论用什么语言去实现这个程序都可以，只是存在难易度和细节的调整问题。难易度和细节指的是一个语言是否具有良好的生态（有没有现成的稳健的依赖包，或者自己有没有积攒一些常用的代码段等），另外就是程序在与外部对接的过程，有没有封装良好的接口。 程序架构的设计是基于需求的目标的，是一个有目的的设计。为了完成最终的目标，我们需要让各个模块按照我们目标运作起来。动起来是最基本的，我们还需要考虑之后的维护过程，怎么让代码更好的去维护，另外还有考虑代码的复用性，这些代码能不能封装起来在之后的项目中使用。 软件工程中有一个名为“高内聚、低耦合”的概念，我们在写代码之前就需要考试考虑好这个问题，低耦合是为了让基本不相关的内容分离设计，高内聚是让一个模块恰好做一件事。在低耦合方面，如果日志模块和缓存模块纠缠在一起，再加一个数据库模块的话难道要再重写一个日志模块？再高内聚方面，一个日志模块不需要分散开写成多个部分，日志模块就是提供一个稳定的标准的日志接口，里面怎么实现是不需要调用者关注的。本人觉得做好“高内聚、低耦合”就能得到一份好维护，复用性强的代码。 做好程序架构的设计之后，就可以开始做语言的选型，从划分的各个模块入手开始做代码的编写。在做语言的选型问题的时候，要考虑与外部对接的难易度，例如与数据库的对接，与外部接口的对接等等，有的语言例如python对这些有很好的支持，但是C++就需要仔细考虑怎么对接的问题。","tags":[{"name":"程序设计","slug":"程序设计","permalink":"https://www.delta1037.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"考研感想","date":"2021-12-27T16:00:00.000Z","path":"2021/Times/考研感想/","text":"22刚考完，趁着脑子清醒做一下总结 一、考试与估分本来准备等佛系出分的，早上看到有人发了专业课的答案，没忍住对了一下，然后就全对了一下答案。下边分享一下做题心理路程： 专业课：130。写上的差不多都对了，大题有两个小问没有写出来，还有一个小问忘记把参数代入计算了，只写了表达式。专业课是华科的824，一共有28个题吧，20个选择填空，写完发现只用了一个小时，五个只有一两问的题，大概用了一个小时（写完选择才用了一个小时啊啊啊，再抬头感觉时间就不够了，有的太难算的直接放弃了），开始最后三道大题剩一个小时，一道二十分钟，奈何慌的一批，疯狂赶进度，最后剩十分钟，没写的就不管了，检查了一遍，封口完事！ 数学：120。选择填空错了两个，有个选择记不清了，大题有个题没写出来，列了个公式，还有个大题的最后计算错了，但是步骤都是对的，其它的好像还行。选择填空一共用了一个小时左右，剩下的全在搞大题了（真是太难算了，刚拿到卷子心里乐开了花，心想这么简单，写着写着就哭了），写完选择填空把答题卡就画了轻轻的一下，想着大题写完再回来检查的（选择太多不确定的了），结果大题写的入迷了，最后十五分钟发现答题卡还没涂，人差点被吓傻了赶紧涂一下（所以最后十分钟就不要继续看题了，把卷子看一下，看看有没有什么需要补充的！） 英语：50。我英语不好，没什么好说的，完型错了一半，阅读+七选五应该错了一个还是两个，翻译能给一分就行，作文加起来给十分就行（写的邀请信狗都不来，大作文套的模板） 政治：50。政治也没啥好说的，我没有背诵的天赋，单选是错了两个左右，多选应该有四五个，所以选择大概能拿四十分，大题都写满了，希望赏给我十分。 综述：保350冲380。 二、考研感想 预谋：三四月份的时候就忽然觉得工作没啥意思，趁着年轻应该多学习。咨询了很多老师，和已经上了研究生的同学，以及一些工作的同学，相互交流了很多意见，工作有工作的好处，读研有读研的好处，各有各的难处，各方权衡下我觉得我想去试一试，因为我没考过研，总觉得差点什么。（之前有一个保研的机会我没有珍惜，这也没什么好后悔的，当时觉得工作很香，工作了一年才了解了工作这件事，工作中也收获了挺多，不算亏！） 辞职：主管来劝我，大概说我是应届生里比较强的（Dian团队出来的哪一个不强，就属我菜了），工作三年也可以拿到一个不亚于研究生的薪资水平，大概是我已经拿了一年的工资有点飘了，好说歹说最后还是辞职了（现在想想确实有点冲动，但是考完研后无论最后有没有考上我都有了更大的收获）。 开始：刚辞职的几天，那个浪啊！租的房子还没到期，每天睡到自然醒，偶尔女朋友过来一起做做饭啥的（做饭是我，刷碗也是我，女朋友参与了吃的部分），买了数学的复习资料，每天看个一两眼，过的挺快活！ 中期：高中的学习方式就是使劲刷题，但是大学和一群优秀的人待久了，又有了别的思路。首先是规划方面，每周我都会做周报，每个周日会安排这周的任务，然后每天完成一项就勾一项（一开始用的有道云笔记软件，后来发现了notion，哎呀妈呀真香），到了周日就对这周的东西做一下总结，看看完成情况（大部分都是完不成的，因为各种各样的原因，总而言之就是我有拖延症（此处应该@钟sir），没完成就完后拖呗，最后拖的实在太多了就削减任务，反正最后很多的题都没写，但是写过的都吃的很透，数学复习全书综合提高我认真刷了两边，最后马马虎虎又看了两遍）。然后就是笔记方面，数一的内容真的是多啊，我记笔记是因为从我二刷复习全书的时候发现前边的都忘了，这第二遍刷完再忘了咋办，果断开始记数学笔记（一刷没有记是因为我对数学还是很有信心的，后来发现忘得一干二净），后来因为发现了notion这个软件，记笔记挺方便的（其实主要是我写字太丑了，我一开始写了纸质的数学笔记，不忍直视。。。），然后开始记数学和专业课的笔记，刚开始记的时候真是太痛苦了，严重拖慢复习进度，一直咬牙坚持着，每周花费大量时间在记笔记上（最后看了一下统计一共得有十几万字了），后来复习完一轮回头看的时候，笔记还是很有用的，能够立马想起来这个地方的知识点都会出什么题（后期就不行了）。最后吧就是适当放松，不要一直紧绷着，该放松得放松。 后期：最后的一段时间我也是慌的一批，感觉啥都不会了（到考场上发现会了也没啥用）。做了最后一段时间的规划，填充的满满当当的（当然，最后大部分没搞完）。每隔一天做一套数学卷子保持手感；我这个专业课也是计算题也得保持手感；每天佛系背政治，刷刷选择题；最后几天发现英语单词忘了一些赶紧去补，每隔一天做一下阅读保持手感（最后几天了，做了20年的题，阅读+七选五错了13个，心态都崩了，还好最后英一阅读没有特别难的点，阅读做的很顺畅）。 总结：无论考没考过都不会再考了，这段考研的日子确实能让人收获很多，爷青结~ 三、资料以下只放我写过的，没写过的不好做出评价。 数学： 复习全书：看了四遍，知识比较系统，每一个知识后都有例题（我第一遍用来看基础知识点和看例题，第二遍不看答案刷了一遍例题并且标注一些难点的题，第三遍就是认真看一下重点标注的题，第四遍是快考试了，看了知识点和重点标注的题） 880：是个习题集就行，刷一遍作为巩固（微积分部分我只写了选择题，线代和概率论差不多都写了） 李艳芳的真题：这个老师出的真题讲解真是太棒了！讲解特别的详细（我是用来写完真题对答案的，我写完真题无论这道题有没有写对都会把答案看一遍，看看答案有没有什么好的思路） 历年真题全精解析：我用来巩固真题用的，看看哪一章都会出什么题（高数认真看了一遍，线代和概率论没来得及看） 一些视频：我的全部都是自学的，没看哪个老师的视频。最后的冲刺阶段在B站上看了李艳芳的高数知识梳理。 专业课： 刺猬哥的复习资料（真题、分类题、知识点）：整体来说挺好的，还有答疑服务（虽然我也没问几次，但是有了一个沟通题目的地方）；真题是熟悉题型用的，最重要；分类题是熟悉知识点用的；知识点那本我没咋看 信号与系统（奥本海姆）：专业课的课本，没啥好说的，我是先看了一遍课本，然后才开始写题的 黄皮书和绿皮书：专业课课本辅导资料，对课后的例题做讲解（今年好像有一个特别难的题是从绿皮书上出的，绿皮书很重要），这两本有重复的题目，对照着勾画一下，重复的题做一遍就行了 英语： 黄皮书：真题和讲解，没啥好说的，挺好用的 唐迟阅读的逻辑：看了一遍确实挺好用，看完之后记得做总结 语法新思维+长难句高分通关：我英语太差了，需要补语法（自知之明） 其它：买了一堆，没怎么写（新东方的资料几乎所有的都买了，除了那两本语法其它的没怎么写） 政治： 肖老的一套：必买，四套卷+八套卷+时政刷个心安，1000题也是必刷的（我有一门没刷完，后期转到小程序刷题了） 刷题软件：都一样的，能刷题就行了，这里因为这个刷题软件侵犯了原著的著作权就不提名字了 四、收尾前边放了大段的文字，下边放几张图 有道云笔记做的周报 notion做的周报 notion做的周报汇总 有道云做的数学计划 notion做的数学计划 notion做的英语阅读笔记 notion做的数学笔记","tags":[{"name":"考研","slug":"考研","permalink":"https://www.delta1037.cn/tags/%E8%80%83%E7%A0%94/"}]},{"title":"Typora图床配置","date":"2021-06-20T16:00:00.000Z","path":"2021/Deploy/Typora图床配置/","text":"Typora图床配置 一、开通阿里云对象存储阿里云对象存储页面 之后购买资源包和新建bucket即可，我所使用的是本地冗余的低频访问存储，因为这个便宜一些，主要是因为我的博客图片量比较少，访问频率不大。 具体阿里云方面的配置参考Typora+PicGo+阿里云OSS实现图片上传功能 二、Typora配置如下图所示 1、在图像-&gt;插入图片时可以选择在插入图片时先将图片拷贝到某一个位置，然后可以根据需要对其进行重命名(有关于此见暂未解决的问题1)，然后右键上传图片即可 2、在图像-&gt;上传服务设定可以设置上传服务，下图中选用PicGo-Core（因为上传图片使用命令行而不是后台常驻进程，减少系统资源消耗），选择完毕之后点击下载或更新可以自动安装；安装完毕之后选择打开配置文件 3、配置文件配置如下所示 text123456789101112131415161718192021&#123; &quot;picBed&quot;: &#123; // 图床的配置 &quot;uploader&quot;: &quot;aliyun&quot;, // 图床类型的选择，这里选择阿里云 &quot;aliyun&quot;: &#123; &quot;accessKeyId&quot;: &quot;xxxxxxxxxx&quot;, // 图床的访问ID &quot;accessKeySecret&quot;: &quot;xxxxxxxxxx&quot;, // 图床的访问密钥，具体设置参考 一、开通阿里云对象存储 &quot;bucket&quot;: &quot;bucket_name&quot;, // bucket名字 &quot;area&quot;: &quot;oss-cn-beijing&quot;, // bucket地区 &quot;path&quot;: &quot;hexo-blog/&quot;, // bucket内部文件夹 &quot;customUrl&quot;: &quot;delta1037.oss-cn-beijing.aliyuncs.com&quot;, // 外网访问bucket域名 &quot;options&quot;: &quot;&quot; &#125; &#125;, // PicGo插件相关配置，后续介绍 &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-rename-file&quot;: true &#125;, &quot;picgo-plugin-rename-file&quot;: &#123; &quot;format&quot;: &quot;&#123;localFolder:1&#125;-&#123;origin&#125;&quot; &#125;&#125; 三、PicGo相关插件插件的安装需要系统中安装nodejs；以下安装插件命令的执行在PicGo的配置文件夹中(例如C:\\Users\\delta1037.picgo，在此文件中打开Powershell窗口即可) 3.1 picgo-plugin-rename-fileshell或者Powershell中执行安装命令 text1npm i picgo-plugin-rename-file 相应的配置解释如下 text1234567// PicGo插件相关配置&quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-rename-file&quot;: true // 控制插件的打开与关闭&#125;,&quot;picgo-plugin-rename-file&quot;: &#123; &quot;format&quot;: &quot;&#123;localFolder:1&#125;-&#123;origin&#125;&quot; // 上传图片时图片的重命名格式&#125; 具体的重命名格式参照github项目主页 暂未解决的问题 1、拷贝到Typora的图片不可以右键重命名（需要先粘贴图片，打开图片位置，重命名，修改Typora中对应的名字步骤，及其繁琐，等待后续Typora更新），相应的issue 2、阿里云设置防盗链之后，Typora上传图片之后无法正常显示","tags":[{"name":"Typora","slug":"Typora","permalink":"https://www.delta1037.cn/tags/Typora/"}]},{"title":"租房指南","date":"2021-05-24T16:00:00.000Z","path":"2021/Life/租房指南/","text":"租房指南。关于费用、房东&amp;中介、怎么找房东~ 一、费用问题 付款方式：押一付一、押一付三；交租方式，保留交租凭证 需要另付的费用由哪些：电费（商业用电和民用电：商业用电贵一些，可能由民用电的两倍）、水费、物业费、网费，家电维修费（对维修费用的出具人做出约定） 克扣押金：合同可以注明租期满后指定工作日内，在房屋或者其设施不存在人为损毁的情况下，应退还全部押金 二、房东&amp;中介 合同可以注明租赁房屋所在的位置、间数、面积、质量、设施清单、租赁期限、租金及支付期限与方式等 审查合同主体是否合格，即出租人与承租人是否具备相应的条件。审查租赁的客体是否合格，即出租人的房屋是否为法律、法规允许出租的房屋。审查房屋租赁手续是否完备。房屋产权证明并非是合法出租的充分条件，还应按有关规定办理房屋租赁许可证，租赁合同也要进行租赁登记方可生效。 房东直租&#x2F;中介：房东直租不需要中介费；如果找中介，中介费一般是房租的一半，在签订合同时一次性缴清 公寓公司：蛋壳自如之类的、一般租金较贵，注意除了每个月的租金之外是否还需要其它费用，一般会有打扫卫生的费用（服务费）；注意是否与银行签订贷款（蛋壳） 三、如何找房东直租现在找租房信息平台有很多，但是内容混杂很难分清是否是真实信息，例如： 在某网站上找的中介，一开始说自己不是蛋壳的，后来又承认是蛋壳的，然后一开始说不需要服务费，提出录音之后又改口 看到明显很“高大上”的房子，但是租金很便宜，一般是压价来吸引客户的，但是也可以问一问 在线看照片是看不准的，一定要线下看房 3.1 找房东直租的方法 豆瓣租房小组上有很多发布的房源信息 八爪鱼采集器来爬取数据相当好用 众所周知，一个人是不可能有七八套房的（特别厉害的当我没说），根据每个用户的发布房源数量来手动做数据清洗 单个用户一直发同一套房那就大概率是房东了 Oh以上整理于毕业租房的真实经历，最后找到了一个比较满意的房子，网上的照片拍的效果太差，最后才看的，线下看还行，所以一定要线下看一下","tags":[{"name":"租房","slug":"租房","permalink":"https://www.delta1037.cn/tags/%E7%A7%9F%E6%88%BF/"}]},{"title":"Terraria服务端搭建","date":"2021-05-19T16:00:00.000Z","path":"2021/Game/Terraria服务端搭建/","text":"Terraria服务端搭建 一、环境准备 Linux x86_64（CentOS 8） 二、搭建2.1 下载官网地址最下方点击PC Dedicated Server（此链接版本为1423版本，当steam启动时更新时，服务端也要做相应的更新）即可下载最新版本的服务端，其中包括Linux&#x2F;Window&#x2F;Mac版本。 2.2 安装将下载到的包上传到服务端 text123456789# 创建存放服务端文件的目录mkdir -p /opt/terraria_server# 解压文件到目录unzip terrraria-server-1423.zip -d /opt/terraria_server# 进入到解压后的Linux对应的目录，并给文件执行权限cd /opt/terraria_server/1423/Linuxchmod +x -R ./ # 注意这里是图方便给改文件夹下所有的文件赋予了可执行权限，也可以单独给需要的文件赋予可执行权限 2.3 配置配置文件 text123# 创建并编辑配置文件## 创建在外层目录不影响更新服务端版本vim /opt/terraria_server/terraria_config 配置内容可填写如下： text12345678910111213141516171819# 启动时选择的地图的路径world=/opt/terraria_server/Worlds/delta1037.wld# 最大连接玩家个数maxplayers=3# 连接密码password=******# 指定端口，默认是7777port=6666# 语言配置language=zh# 当地图不存在时创建新地图的配置## 地图难度difficulty=0## 地图大小 1(小), 2(中), and 3(大).autocreate=3## 地图路径和名字worldpath=/opt/terraria_server/Worldsworldname=delta1037.wld 完整的配置见Terraria官方配置说明 三、启动服务端text12345# 进入到主程序目录cd /opt/terraria_server/1423/Linux# 使用配置文件启动./TerrariaServer.bin.x86_64 -config /opt/terraria_server/terraria_config 参考【0】Linux搭建泰拉瑞亚服务器","tags":[{"name":"Terraria","slug":"Terraria","permalink":"https://www.delta1037.cn/tags/Terraria/"}]},{"title":"tModLoader服务端搭建","date":"2021-05-19T16:00:00.000Z","path":"2021/Game/tModLoader服务端搭建/","text":"tModLoader服务端搭建。 tModLoader是Terraria的Mod版本，服务端发布在github，tModLoader服务端的运行需要Terraria的服务端的支持。 一、环境准备 Linux x86_64（CentOS 8） 二、搭建2.1 下载在tModLoader发布页下载最新版本的发布版本，并在Terraria官网地址最下方点击PC Dedicated Server（此链接版本为1423版本）即可下载最新版本的Terraria服务端。获取到包： terraria-server-1423.zip ： Terraria最新安装包 tModLoader.Linux.v0.11.8.4.zip ： tModLoader最新发布的包 2.2 安装安装服务端： text1234567891011121314# 创建服务端安装位置，并切换到安装位置mkdir -p /opt/t_mod_server/servercd /opt/t_mod_server/server# 将Terraria的服务端的安装包拷贝到安装位置并使用unzip解压unzip terraria-server-1423.zip# 将解压的文件拷贝到当前目录中cp -r 1423/Linux/* ./# 将tModLoader的安装包拷贝到安装位置并使用unzip解压，这个时候tModLoader解压的文件会替换Terraria服务端文件中的部分文件unzip tModLoader.Linux.v0.11.8.4.zip# 给文件赋予可执行权限chmod +x -R ./ # 注意这里是图方便给改文件夹下所有的文件赋予了可执行权限，也可以单独给需要的文件赋予可执行权限 2.3 配置创建配置文件路径、Mod路径和地图路径 text12345678# 创建配置路径mkdir -p /opt/t_mod_server/config# 使用自定义Mod位置和地图位置配置## 创建Mod路径，Mod路径中存放mod和一个表示是否开启Mod的json文件，如果不清楚等下可以由系统创建mkdir -p /opt/t_mod_server/Mods## 创建地图路径mkdir -p /opt/t_mod_server/Worlds 新建并编辑配置文件 text1vim /opt/t_mod_server/config/t_mod_loader_config 配置文件内容如下： text12345678910111213141516171819202122# 最大连接个数maxplayers=3# 指定端口，默认是7777port=6666# 连接密码password=1037forest# Mod路径和地图路径modpath=/opt/t_mod_server/Modsworld=/opt/t_mod_server/Worlds/delta1037.wld# 语言language=zh# 创建新地图参数## 地图难度difficulty=0## 地图大小 1(小), 2(中), and 3(大).autocreate=3## 地图路径和名字worldpath=/opt/terraria_server/Worldsworldname=delta1037.wld 完整的参数见Starting a modded server和Terraria官方配置说明 Mod路径下的内容： text1234567➜ Mods pwd/opt/t_mod_server/Mods➜ Mods lsenabled.json MagicStorage_v0.4.3.5.tmod Split_v0.4.0.13.tmodLocalizer_v1.5.0.19.tmod RecipeBrowser_v0.8.8.2.tmod ThoriumMod_v1.6.4.1.tmod# 注：Mod路径下除了一个enabled.json文件其余全是Mod文件 enabled.json文件内容（该json文件是一个字符串列表，每一个字符串是Mod的名字，如果需要去掉某个Mod需要将对应的字符串删除，即不加载该Mod）： text123456[ &quot;Split&quot;, &quot;RecipeBrowser&quot;, &quot;MagicStorage&quot;, &quot;ThoriumMod&quot;] 注意!!!： 1、Mod路径和地图路径默认位置在/username/.local/share/Terraria/ModLoader，username是当前登录用户的用户名 2、当不知道**enabled.json**的格式是什么样的时候，将需要加载的mod放入到/root/.local/share/Terraria/ModLoader/Mods中，切换到tModLoader主程序文件夹/opt/t_mod_server/server中，不加参数直接启动主程序（启动：./tModLoaderServer.bin.x86_64）,显示输出类似如下： text12345678910Terraria Server v1.3.5.3 - tModLoader v0.11.8.41 1037forest2 testn New Worldd &lt;number&gt;Delete Worldm Mods Menub Mod BrowserChoose World: 输入m可以选择是否加载（enable）mod或者取消（disable）mod 界面如下： text12345678910111213Terraria Server v1.3.5.3 - tModLoader v0.11.8.41 Localizer (enabled)2 Magic Storage (enabled)3 Recipe Browser (enabled)4 Split (enabled)5 Thorium Mod (enabled)e Enable Alld Disable Allr Reload and return to world menuType a number to switch between enabled/disabledType a command: 选择完成之后使用r重载并返回到上一级，这时使用Ctrl + C退出，即可获取到/root/.local/share/Terraria/ModLoader/Mods/enable.json文件，将该文件拷贝到指定的Mod路径下即可使用。 2.4 启动text12345# 进入到主程序目录cd /opt/t_mod_server/server# 使用配置文件启动./tModLoaderServer.bin.x86_64 -config /opt/t_mod_server/config/t_mod_loader_config 参考【0】Starting a modded server 【1】How to create a tModLoader&#x2F;Modded server on Linux","tags":[{"name":"Terraria","slug":"Terraria","permalink":"https://www.delta1037.cn/tags/Terraria/"}]},{"title":"C++ List Shuffle","date":"2021-05-16T16:00:00.000Z","path":"2021/C_C++/C++ListShuffle/","text":"目前C++只提供了可随机访问的容器的shuffle接口，对于List容器该接口不可用，这里提供一个List shuffle函数模板 一、随机访问容器shuffle12345# 生成随机种子unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();# 使用默认的随机引擎来打乱容器中的元素std::shuffle(v.begin(), v.end(), std::default_random_engine(seed)); 二、List shuffle函数模板123456789101112131415template &lt; typename T &gt; void list_shuffle( std::list&lt;T&gt;&amp; lst ) // shuffle contents of a list&#123; // create a vector of (wrapped) references to elements in the list // http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper std::vector&lt; std::reference_wrapper&lt; const T &gt; &gt; vec( lst.begin(), lst.end() ) ; // shuffle (the references in) the vector std::shuffle( vec.begin(), vec.end(), std::mt19937&#123; std::random_device&#123;&#125;() &#125; ) ; // copy the shuffled sequence into a new list std::list&lt;T&gt; shuffled_list &#123; vec.begin(), vec.end() &#125; ; // swap the old list with the shuffled list lst.swap(shuffled_list) ;&#125; 参考【0】 how to shuffle a list?","tags":[{"name":"C++","slug":"C","permalink":"https://www.delta1037.cn/tags/C/"}]},{"title":"动态库文件的装载","date":"2021-05-16T16:00:00.000Z","path":"2021/C_C++/动态库文件的装载/","text":"动态库状态过程的细节，待整理 动态符号表（.dynsym）是一个符号集，保存动态链接相关的符号，这些符号对于运行时的动态对象是可见的。在动态链接过程中，如果发现未定义的动态符号，链接器会把动态符号加入到动态符号表。但是我们的插件是显示地运行时链接的（为了减少与主程序的耦合），不可能在编译过程中就动态链接到对应的插件库，所以只能主动导出插件中使用的未定义的符号（注册与反注册符号）到动态符号表中，所以在编译主程序时，使用-Wl,-E（-Wl,–export-dynamic）链接器参数将主程序中所有的符号导出到动态符号表中。这样在使用dlopen打开插件动态库时，插件动态库中相关的注册和反注册接口符号在主程序的动态符号表中就有了定义，于是就可以正常运行了。使用readelf –dyn-syms + 可执行文件或动态库可以查看可执行文件或者动态库中的动态符号表。本例中动态库中动态符号表部分内容如下：Symbol table ‘.dynsym’ contains 22 entries: Num: Value Size Type Bind Vis Ndx Name 1: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _Z19unregister_ioengineP1 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#112;&#x72;&#x69;&#110;&#x74;&#x66;&#64;&#71;&#x4c;&#x49;&#x42;&#67;&#x5f;&#50;&#46;&#50;&#46;&#x35; (2) 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _Z17register_ioengineP11I 13: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#x70;&#x74;&#104;&#x72;&#101;&#97;&#x64;&#95;&#115;&#101;&#x6c;&#x66;&#64;&#71;&#76;&#x49;&#x42;&#x43;&#95;&#50;&#46;&#x32;&#46;&#53; (3) 14: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#112;&#x72;&#101;&#97;&#x64;&#x36;&#x34;&#x40;&#x47;&#x4c;&#73;&#x42;&#67;&#x5f;&#50;&#x2e;&#x32;&#46;&#x35; (3) 15: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#x70;&#x77;&#x72;&#105;&#116;&#x65;&#x36;&#52;&#x40;&#71;&#76;&#73;&#x42;&#x43;&#x5f;&#x32;&#46;&#x32;&#46;&#x35; (3) 16: 0000000000202080 80 OBJECT GLOBAL DEFAULT 24 ioengine从中可以看出注册和反注册接口、以及调用glic库中的符号的是未定义（UND）状态，需要在加载时确定这些符号的位置，glic库相关的符号在加载glic库时完成确定，注册与反注册则需要在主程序中确定位置，所以主程序的动态符号表必须有这两个符号的定义。主程序在未加-Wl,-E参数编译时，动态符号表内容如下：Symbol table ‘.dynsym’ contains 87 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#x5f;&#x5a;&#78;&#x53;&#x73;&#x61;&#83;&#69;&#80;&#75;&#x63;&#x40;&#71;&#x4c;&#73;&#x42;&#x43;&#x58;&#88;&#x5f;&#x33;&#46;&#x34; (2) 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#x5f;&#x5a;&#78;&#x53;&#115;&#67;&#x31;&#x45;&#118;&#64;&#x47;&#x4c;&#x49;&#x42;&#67;&#x58;&#x58;&#95;&#51;&#46;&#52; (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#112;&#x72;&#x69;&#x6e;&#116;&#102;&#x40;&#x47;&#x4c;&#73;&#66;&#67;&#95;&#x32;&#x2e;&#x32;&#x2e;&#x35; (3) 4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#95;&#x5a;&#x53;&#116;&#x32;&#49;&#x5f;&#95;&#x74;&#104;&#x72;&#x6f;&#x77;&#x5f;&#114;&#x75;&#x6e;&#116;&#105;&#x6d;&#x65;&#x5f;&#101;&#114;&#x72;&#64;&#71;&#76;&#x49;&#x42;&#x43;&#88;&#x58;&#95;&#x33;&#46;&#x34; (2) 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND &#x73;&#x6e;&#112;&#114;&#x69;&#x6e;&#x74;&#102;&#64;&#71;&#x4c;&#73;&#x42;&#67;&#x5f;&#x32;&#46;&#x32;&#x2e;&#x35; (3)其中只包含一些调用其它动态库的动态符号内容，像glibc库这些第三方库中的符号。 主程序在添加-Wl,-E参数编译时，动态符号表内容过多，添加grep过滤（readelf –dyn-syms main_prj | grep register）可得：240: 0000000000410dd5 218 FUNC GLOBAL DEFAULT 14 _Z17register_ioengineP11I 596: 0000000000410eaf 211 FUNC GLOBAL DEFAULT 14 _Z19unregister_ioengineP1可以看出在使用了-Wl,-E参数后，动态符号表中多出了一些主程序中内部函数的符号，包含插件注册与反注册接口的符号（符号修饰名与插件中的修饰名一致）。 参考：.dynsym：动态符号表：保存动态链接相关的导入导出的符号，不包括模块内部符号.dynsym默认会导出使用其它动态链接库的符号主程序在编译时默认只会导出未定义的符号（将来从动态库中加载）和动态库中定义了并且被使用的符号（定义了函数定义，并有实现和调用）。不会导出有定义但是没有使用的符号。所以当插件需要向主程序注册时，主程序中需要有注册函数符号，才能被插件调用。gcc编译使用-Wl,-E参数可以导出所有符号。主程序加载动态库时，动态符号表会进行合并合并到GOT表显式运行时链接查看动态符号表：readelf –dyn-syms plugin_test待补充的内容：动态表是怎么链接到一起的，动态库加载的时候做了什么？动态链接过程中如果发现未定义的动态符号，链接器会把动态符号加入动态符号表（所以第一个例子中，程序输出正常），但是fun符号因为是在dlopen中（dlopen发生在运行过程中）调用的，不会加入到动态符号表，所以导致找不到符号。-E’–export-dynamic’当创建一个动态连接的可执行程序时, 把所有的符号加到动态符号表中.动态符号表是一个符号集,这些符号对于运行时的动态对象是可见的.如果你不使用这个选项,动态符号表中就会只含有那些连接进来的动态对象中用到的符号 如果你使用’dlopen’来载入动态对象,它需要引用程序中的符号,那你可能需要在连接程序时用到这个选项.你也可以使用版本脚本来控制哪些符号应当被加到动态符号表中.","tags":[{"name":"C++","slug":"C","permalink":"https://www.delta1037.cn/tags/C/"}]},{"title":"pg_repack Window编译安装","date":"2021-05-16T16:00:00.000Z","path":"2021/Deploy/pg_repackWindow编译安装/","text":"在Window上编译安装pg_repack （在线清理表空间插件） pg_repack Window编译安装一、编译准备1.1 pg_repack下载pg_repack下载位置：https://pgxn.org/dist/pg_repack&#x2F;1.4.6&#x2F; 目前最新版本为4.6版本 1.2 postgres版本选择编译时需要在编译机器上安装postgre，官网可以下载到的版本是9.6.21，经测试9.6.21可以使用 二、编译pg_repack注：已经做完以下所有配置和修改的代码打包为pg_repack-1.4.6_modify.zip，使用vs2013打开解压之后其中的msvc文件夹下的pg_repack.sln即可编译。 2.1使用vs2013打开pg_repackpg_repack-1.4.6.zip解压得到pg_repack-1.4.6目录，进入pg_repack-1.4.6\\msvc可以看到2010的sln文件，经测试vs2013版本也可以正常编译，使用vs2013打开pg_repack.sln并升级，可以看到bin和lib两个项目 2.2添加并选择pg_repack 64位编译配置鼠标右键点击解决方案pg_repack，选择配置属性-&gt;配置，可以看到bin和lib两个项目都是32位平台下的配置，如下图所示： 我们需要x64位平台配置，点击右上角配置管理器，点击如下图红框所标示的下拉按钮位置，并选择新建 新平台选择x64，并选择从Win32复制，如下图 新建完成之后返回到配置属性-&gt;配置，选择刚刚新建的x64平台，选择完成如下图： 2.3禁用将警告视为错误bin和lib两个项目都要禁用将警告视为错误，以下以bin项目为例，lib项目同理。 bin项目禁用将警告视为错误：选中bin项目，点击鼠标右键，选择配置属性-&gt;C&#x2F;C++-&gt;常规，将警告视为错误选择否，如下图： lib项目进行同样的操作。 2.4注册PostgreSQL的目录bin和lib两个项目都要注册PostgreSQL的包含目录和库目录，以下以bin项目为例，lib项目同理。 bin项目添加包含目录：选中bin项目，点击鼠标右键，选择配置属性-&gt;VC++目录，选择如下图所示的下拉位置并点击编辑 添加PostgreSQL的头文件目录（根据实际PostgreSQL安装目录决定）： C:\\Program Files\\PostgreSQL\\9.6\\include C:\\Program Files\\PostgreSQL\\9.6\\include\\internal C:\\Program Files\\PostgreSQL\\9.6\\include\\server C:\\Program Files\\PostgreSQL\\9.6\\include\\server\\port\\win32 C:\\Program Files\\PostgreSQL\\9.6\\include\\server\\port\\win32_msvc 添加完成后如下图所示： bin项目添加库目录：选中bin项目，点击鼠标右键，选择配置属性-&gt;VC++目录，选择库目录位置，如下图， 添加PostgreSQL的库文件目录（根据实际PostgreSQL安装目录决定）： C:\\Program Files\\PostgreSQL\\9.6\\bin C:\\Program Files\\PostgreSQL\\9.6\\lib 添加完成后如下图所示： lib项目同样的操作，注册PostgreSQL的包含目录和库目录。 2.5删除lib项目不存在的源文件lib项目src路径下有一个不存在的文件pgut-be.c，选中并delete即可。删除之后如下图 2.6 bin项目修改链接库选中bin项目，点击鼠标右键，选择配置属性-&gt;链接器-&gt;输入，选择附加依赖项并展开选择编辑 1、libintl-8.lib修改为libintl.lib 2、添加postgres.lib 修改完成之后如下图所示 2.7打入版本号bin和lib两个项目在编译时无法打入版本号，所以对源代码repack.c和pg_repack.c文件进行了修改，修改之后如下 bin项目为例，点击鼠标右键，选择配置属性-&gt;C&#x2F;C++-&gt;命令行，在其它选项框中填入&#x2F;D “WIN_BUILD”，如下图： lib项目需要做同样的配置 2.8编译项目分别选中bin和lib两个项目（不分先后），鼠标右键选择生成。 生成的文件在pg_repack-1.4.6\\msvc\\x64\\Release相对路径下，有pg_repack.dll和pg_repack.exe两个文件 三、插件文件汇总注：已经做完编译和修改的文件在压缩包中可以看到 3.1 pg_repack二进制文件上边编译好的pg_repack.dll和pg_repack.exe两个文件 3.2 pg_repack扩展安装辅助文件在pg_repack-1.4.6\\lib相对路径下有pg_repack.sql.in和pg_repack.control.in两个文件，分别拷贝为pg_repack.sql和pg_repack.control 打开pg_repack.sql文件，将REPACK_VERSION替换为版本号1.4.6 修改之后为 打开pg_repack.control文件 将REPACK_VERSION替换为版本号1.4.6；替换module_pathname的值为实际的插件安装DLL文件的路径（插件安装在后续介绍） 修改之后 四、插件安装4.1放入插件相关文件以下描述使用相对路径，均为pStor中PostgreSQL的路径 1、pg_repack–1.4.6.sql和pg_repack.control放入到PostgreSQL\\share\\extension\\中 2、pg_repack.dll和pg_repack.exe放入到PostgreSQL\\bin\\中 注意pg_repack.control中module_pathname的值与pg_repack.dll路径位置一致 4.2登录到数据库并添加插件1、登录到想要使用插件的数据库（cmd中PostgreSQL\\bin\\路径下运行，注：使用管理员用户，否则权限不够无法添加） psql.exe -h hostname -p port -d database_name -U super_user 2、 安装插件（在登录之后的提示命令中执行）， 执行命令：create extension pg_repack; 使用\\dx列出插件看是否安装成功： 注：卸载插件命令（drop extension pg_repack;） 3、 检查是否安装成功（在cmd中PostgreSQL\\bin\\路径下运行，应该输出pg_repack版本号） pg_repack –version","tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://www.delta1037.cn/tags/PostgreSQL/"}]},{"title":"C/C++插件式设计","date":"2021-03-11T16:00:00.000Z","path":"2021/C_C++/C-C++插件式设计/","text":"Fio中的插件式设计分析，抽取出来一份模板。 一、设计来源并不是我设计的哈哈哈哈~ 最近看fio的源代码，学习了一波fio中关于IO引擎的插件式设计，对重要的一些部分做了摘要。以下是我的总结，其中有一些是我的猜测，有待验证 名词解释： 名词 解释 主程序 调用插件的程序 插件 可以被方便地替换地部分 二、插件与主程序的结构关联主程序如果想使用插件中的函数，则需要知道插件中对应函数的地址，所以我们可以定义一个结构体集合，用来保存插件提供函数的地址，和其它相关内容。在使用插件时我们只要找到了该结构体的位置，就相当于找到了插件中提供的函数的位置。例如 text12345678910struct PluginStruct &#123; char *plugin_name; int plugin_version; int (*init)(struct thread_data *); int (*uninit)(struct thread_data *); int (*io_write)(struct thread_data *, struct io_unit*); int (*io_read)(struct thread_data *, struct io_unit*);&#125;; 在本例中，我们准备做一个读写文件的插件，插件一使用write/read方式读写；插件二使用pwrite/pread方式读写。如上述结构体中：init和uninit是插件的初始化和反初始化，io_write和io_read是对读写接口的封装。 插件可能是由多线程来调用的，为了表明这一点，插件接口的参数中使用结构体struct thread_data来表示每个线程的私有数据（fio中也是用的thread_data）。 插件中也可能想保存私有数据，但是由于不知道有多少线程会使用该插件，所以只能将数据保存到结构体struct thread_data中plugin_data，然后在插件中做类型转换，结构体struct thread_data只是作为私有数据的plugin_data承载作用，私有数据plugin_data在init和uninit中分别申请空间和释放空间，对于外部来说可以做到‘神不知，鬼不觉’。 为了能够做到基本的数据读写，结构体struct thread_data和struct io_unit定义如下 text1234567891011121314151617181920212223242526/* 文件属性，用于保存每个线程操作的文件信息 */struct FileAttr &#123; char *file_name; int fd;&#125;;/* 线程数据，保存一个线程用到的所有数据 */struct thread_data &#123; /* some thread private data */ int thread_id; pthread_t thread_handle; struct PluginStruct *plugin_struct; // 通过该变量访问插件中的函数地址 void *plugin_private_data; struct FileAttr *file_attr; // 保存该线程用到的文件信息 void *plugin_dll_handle; // 共享库句柄&#125;;/* io操作单元，一次IO操作必要的信息 */struct io_unit &#123; void *buffer; // 缓冲区地址 uint64_t size; // 读写大小 uint64_t offset;// 读写偏移&#125;; 以上的结构体均定义在主程序头文件中，插件只是使用这些结构体类型，或访问内存中的值，或定义变量。 完整的插件需要包含的主程序头文件plugin.h定义如下 text1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// plugin.h// 插件在加载和关闭时，自动调用的构造函数和析构函数 标识？#define plugin_init __attribute__((constructor))#define plugin_exit __attribute__((destructor))/* 文件属性，用于保存每个线程操作的文件信息 */struct FileAttr &#123; char *file_name; int fd;&#125;;/* 线程数据，保存一个线程用到的所有数据 */struct thread_data &#123; /* some thread private data */ int thread_id; pthread_t thread_handle; struct PluginStruct *plugin_struct; // 通过该变量访问插件中的函数地址 void *plugin_private_data; struct FileAttr *file_attr; // 保存该线程用到的文件信息 void *plugin_dll_handle; // 共享库句柄&#125;;/* io操作单元，一次IO操作必要的信息 */struct io_unit &#123; void *buffer; // 缓冲区地址 uint64_t size; // 读写大小 uint64_t offset;// 读写偏移&#125;;struct PluginStruct &#123; char *plugin_name; int plugin_version; int (*init)(struct thread_data *); int (*uninit)(struct thread_data *); int (*io_write)(struct thread_data *, struct io_unit*); int (*io_read)(struct thread_data *, struct io_unit*);&#125;;// 插件向主程序注册和反注册接口extern void plugin_register(struct PluginStruct *);extern void plugin_unregister(struct PluginStruct *); 三、插件向主程序注册&#x2F;主程序主动加载插件fio中IO引擎的注册包含了两种，（猜测是为了防止其中一种失败，然后采用另一种方式）。 主程序主动加载插件方式是主程序通过dlopen()、dlsym()和dlclose()系列函数完成插件中struct PluginStruct结构体变量的加载，从而获取到插件中相应函数的地址；插件向主程序注册方式是主程序在加载插件动态库时，自动调用某些”构造函数”，而在构造函数中调用主程序的注册函数可以完成插件的注册。 插件程序定义如下： text12345678910111213141516171819202122232425262728293031323334353637383940414243444546// plugin_1.c/* 包含定义插件必须的头文件 */#include &quot;plugin.h&quot;// 插件私有变量定义struct plugin_private_data &#123; // some private data int write_call_times; int read_call_times;&#125;static int plugin_1_init(struct thread_data *td)&#123;&#125;static int plugin_1_uninit(struct thread_data *td)&#123;&#125;static int plugin_1_io_read(struct thread_data *td, struct io_unit *io_u)&#123;&#125;static int plugin_1_io_write(struct thread_data *td, struct io_unit *io_u)&#123;&#125;// 注册所有本插件的相关函数到插件结构体中struct PluginStruct plugin = &#123; .plugin_name = &quot;plugin_1&quot;, .plugin_version = 1, .init = plugin_1_uninit, .uninit = plugin_1_uninit, .io_write = plugin_1_io_write, .io_read = plugin_1_io_read,&#125;;// 插件动态库在加载时会自动调用该函数，因为plugin_init的原因static void plugin_init plugin_1_auto_register()&#123; plugin_register(&amp;plugin);&#125;// 插件动态库在关闭时会自动调用该函数static void plugin_exit plugin_1_auto_unregister()&#123; plugin_unregister(&amp;plugin);&#125; 3.1 主程序主动加载插件主程序通过dlopen()、dlsym()和dlclose()系列函数完成插件中plugin变量的加载，从而完成插件的注册，这种方式的前提是插件中一定定义了plugin变量，否则无法完成插件的加载。 主动加载示例如下： text123456789101112131415// plugin.cstatic PluginStruct* load_plugin(struct thread_data *td, char *plugin_dll_path)&#123; struct PluginStruct *plugin; void *dll_handle = dlopen(plugin_dll_path, RTLD_LAZY); if (!dll_handle) &#123; return NULL; &#125; plugin = dlsym(dll_handle, plugin_dll_path); // 这是啥？ if (!plugin)&#123; plugin = dlsym(dll_handle, &quot;plugin&quot;); &#125; return plugin;&#125; 3.2 插件向主程序注册插件中需要定义的代码如下： text12345678910// plugin_1.c// 插件动态库在加载时会自动调用该函数，因为plugin_init的原因static void plugin_init plugin_1_auto_register()&#123; plugin_register(&amp;plugin);&#125;// 插件动态库在关闭时会自动调用该函数static void plugin_exit plugin_1_auto_unregister()&#123; plugin_unregister(&amp;plugin);&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://www.delta1037.cn/tags/C/"}]},{"title":"C/C++调用外部程序","date":"2021-02-03T16:00:00.000Z","path":"2021/C_C++/C-C++调用外部程序/","text":"C&#x2F;C++中调用外部程序的接口：exec系列函数、system、popen 一、exec库函数基于系统调用execve()，提供了一系列冠以exec来命名的上层库函数，虽然接口方式各异，但功能一致。 1.1 执行新程序：execve()系统调用execve()可以将新的程序加载到调用者进程的内存空间。这一操作过程中，进程的栈、数据以及堆段会被新的程序相应部件替换。一般由fork()生成的子进程对execve()的调用最常见。 execve()系统调用定义如下： text1234#include &lt;unistd.h&gt;int execve(const char *pathname, char *const argv[], char *const envp[]);/* 成功不返回，失败返回-1 */ execve()系统调用参数说明： pathname是准备载入当前进程空间的新程序的路径名。pathname可以是绝对路径，也可以是相对调用进程当前工作目录（current working directory）的相对路径 argv指定了传递给新进程的命令行参数。argv是由字符串指针组成的列表，并且以NULL值结尾。其中argv[0]的值对应于命令名，通常来说与pathname中的basename（路径的最后部分）值相同。 envp指定了新程序的环境列表。对应于新程序的environ数组，也是由字符串指针组成的列表，格式为name=value，并且以NULL值结尾。 调用execve()之后,因为同一进程依然存在，所以进程ID不变。 1.2 exec()库函数基于系统调用，库函数提供了多种API选择，这些API都构建于execve()之上，只是在为新程序指定程序名，参数列表以及环境变量的方式上有所不同。 exec()库函数API如下： text12345678#include &lt;unistd.h&gt;int execle(const char *pathname, const char * arg, ... /*, (char*)NULL, char *const envp[] */);int execlp(const char *filename, const char * arg, ... /*, (char*)NULL */);int execvp(const char *filename, char *const argv[]);int execv(const char *pathname, char *const argv[]);int execl(const char *pathname, const char * arg, ... /*, (char*)NULL */);/* 成功不返回，失败返回-1 */ exec()库函数之间的差异总结 函数 对程序文件的描述（-,p） 对参数的描述（v,l） 环境变量来源（e,-） execve() 路径名 数组 envp参数 execle() 路径名 列表 envp参数 execlp() 文件名+PATH 列表 调用者的environ execvp() 文件名+PATH 数据 调用者的environ execv() 路径名 数组 调用者的environ execl() 路径名 列表 调用者的environ fexecve()执行由文件描述符指定的程序。有些应用程序需要打开某个文件，通过执行校验和之后再运行该程序，这一场景就比较适合使用fexecve()，该接口定义如下： text12345#define _GNU_SOURCE#include &lt;unistd.h&gt;int fexecve(int fd, char *const argv[], char *const envp[]);/* 成功不返回，失败返回-1 */ 1.3 解释器脚本解释器(interpreter)是能够读取并执行文本格式命令的程序。（相形之下，编译器是将源代码译为可在真实或者虚拟机上执行的机器语言）解释器通常可以从被称为脚本的文件中读取和执行命令。 UNIX内核运行解释器脚本的方式与二进制程序无异，前提是：1、必须赋予脚本可执行权限；2、文件的起始行必须执行运行脚本的解释器路径名，格式如下： text12345#! interpreter# 其中# 1、#!必须置于改行起始处，这两个字符可以与解释器的路径名使用空格分割# 2、在解释解释器路径名时不会使用环境变量PATH，所以解释器路径一般使用绝对路径# 3、解释器路径名后可以跟随可选参数，二者以空格分隔，但是可选参数中不应包含空格（Linux系统不会将对可选参数中的中的空格做特殊解释，从参数起始到行尾视为一个单词，并且要求脚本的#!起始行不超过127个字节，包括换行符） 当调用execve()来运行脚本时，execve()如果检测到传入的文件以两字节序列开始，就会析取该行剩余的部分（路径名和参数）。然后按照如下格式执行解释器程序： text1interpreter-path [optional-arg] script-path arg interpreter-path(解释器路径)和optional-arg(可选参数)都取自脚本的#!行，script-path时传递给execve()的路径名，arg是通过argv传递给execve()的参数列表（argv[0]排除在外）。 二、执行shell命令：system程序可以通过调用system()函数来执行任意的shell命令，函数定义如下： text12345678#include &lt;stdlib.h&gt;int system(const char*command);# 返回值定义如下# 1、当command命令为NULL指针时，如果shell可用则system()返回非0值，如果不可用则返回0# 2、如果无法创建子进程或者无法获取其终止状态，system返回-1# 3、如果子进程不能执行shell，则system返回值与子shell调用_exit(127)终止时一样# 4、如果所有的系统调用都成功，system返回执行command的子shell的终止状态。shell的终止状态是执行最后一条命令时的退出状态；如果命令被信号所杀，大多数shell会以128+n的值退出，其中n为信号编号 函数system()创建一个子进程来运行shell，并以之执行命令command。所以使用system()函数运行命令至少会创建两个进程，一个用于运行shell，另一个或者多个用于运行shell所执行的命令（如果对效率或者速度有要求，最好直接调用fork()和exec()来执行既定程序）。 三、通过管道与shell命令通信popen管道的一个常见的用途是执行shell命令并读取或向其发送一些输入。popen()和pclose()简化了这个任务，函数定义如下： text123456#include &lt;stdio.h&gt;FILE *popen(const char *command, const char *mode);/* 成功时返回文件流指针，失败时返回NULL并设置errno */int pclose(FILE *stream);/* 成功时返回子进程结束状态，失败返回-1 */ popen()函数创建了一个管道，然后创建了一个子进程来执行shell，而shell又创建了一个子进程来执行command字符串。其中mode是一个字符串，它确定调用进程是从管道中读取数据（mode是r）或者是写入到管道中（mode是w），由于管道是单向的，所以无法在执行的command中进行双向通信。 与使用pipe()创建的管道一样，当从管道中读取数据时，调用进程在command关闭管道的写入端之后会看到文件结束；当向管道写入数据时，如果command已经关闭了管道的读取端，那么调用进程会收到SIGPIPE并的到EPIPE错误。 当IO结束之后可以使用pclose()函数关闭管道并等待子进程中的shell终止（不应该使用fclose()函数，因为它不会等待子进程）。pclose()在成功时会返回子进程中shell的终止状态（即shell命令执行最后一条命令的终止状态，除非是被信号杀死的）。与system()一样，如果无法执行shell，pclose()会返回一个值就像是子进程中的shell调用_exit(127)来终止一样。如果发生了其它错误，那么pclose()返回-1。 参考文献【0】Linux&#x2F;UNIX系统编程手册","tags":[{"name":"C++","slug":"C","permalink":"https://www.delta1037.cn/tags/C/"}]},{"title":"计算机系统","date":"2021-01-30T16:00:00.000Z","path":"2021/OS/计算机系统/","text":"深入理解计算机系统中关于系统的摘要 计算机系统一、硬件组织1.1 总线总线被设计成传送定长的字节块，也就是字（word）。现在大多数机器要么是4个字节（32位），要么是8个字节（64位）。 1.2 I&#x2F;O设备I&#x2F;O设备是是系统与外部的联系通道。基本的I&#x2F;O设备包括：作为用户输入的鼠标和键盘、作为用户输出的显示器和用于长期存储数据和程序的磁盘驱动器（磁盘）。 每一个I&#x2F;O设备都通过一个控制器或适配器与I&#x2F;O总线相连。控制器是IO设备本身或者系统的主印制电路板（主板）上的芯片组。适配器是插在主板插槽上的卡。 1.3 主存主存是一个临时存储设备。在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来讲，主存是一组动态随机存取存储器（DRAM）组成的；从逻辑上来说，存储器是一个线性的字节数组，每个字节有唯一的地址。 1.4 处理器中央处理单元（CPU），简称处理器，是解释（执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。 从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新计数器，使之指向下一条指令。 二、操作系统操作系统的两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常不同的低级硬件设备。 2.1 进程进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，每个进程像是独占地使用硬件。 一个CPU看上去在并发地执行多个进程，这是通过进程间的切换实现的。操作系统实现这种交错执行的机制称为上下文切换，操作系统保持跟踪进程运行所需的所有的状态信息，这些状态信息就是上下文。 2.2 线程在现代操作系统中，一个进程实际上是可以由多个称为线程的执行单元组成，每个线程运行在进程的上下文中，并共享同样的代码和全局数据。 2.3 虚拟内存虚拟内存是一个抽象概念，为每一个进程提供了一个假象——每个进程在独占地使用主存。每个进程看到地内存都是一致地，称为虚拟地址空间。 Linux进程地虚拟地址空间是由大量准确定义地区域组成的。从低地址到高地址主要有： 只读的代码和数据、读&#x2F;写数据：对所有的进程来说，代码是从一个固定的地址开始的。代码区和数据区是直接按照可执行目标文件的内容初始化的。 运行时堆：堆可以在运行时进行动态地扩展和收缩 共享库：大约在地址空间的中间部分。 用户栈：编译器用它来实现函数调用。每调用一个函数，栈就会增长；从一个函数返回时，栈会收缩。 内核虚拟内存：为内核保留，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，必须调用内核来执行这些操作。 2.4 文件文件就是字节序列。每一个IO设备甚至是网络，都可以看成是文件。系统中的所有输入输出都是通过一组Unix I&#x2F;O的系统函数调用读写文件来实现的。 三、计算机系统中的抽象 文件是对I&#x2F;O设备的抽象 虚拟内存是是对程序存储器的抽象（主存和磁盘的抽象） 进程是对一个正在运行的程序的抽象（处理器、主存和I&#x2F;O设备的抽象） 参考资料【0】深入理解计算机系统","tags":[{"name":"系统","slug":"系统","permalink":"https://www.delta1037.cn/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"经济学十大原理","date":"2020-12-08T16:00:00.000Z","path":"2020/Economics/经济学十大原理/","text":"经济学十大原理 一、十大原理分类1.1 人们如何做出决策原理一：人们面临权衡取舍为了得到一件喜爱的东西，我们通常不得不放弃另一件喜爱的东西。做出决策就是要求我们在一个目标与另一个目标之间进行权衡取舍。 人们只有了解面临的选择，才有可能做出良好的决策。 原理二：某种东西的成本是为了得到它所放弃的东西一种东西的机会成本是为了得到这种东西所放弃的东西 原理三：理性人考虑边际量理性人通常比较边际收益与边际成本来做决策。当且仅当一种行为的边际收益大于边际成本时，一个理性的决策者才会采取这种行为。 原理四：人们会对激励做出反应激励是引起一个人做出某种行为的东西（例如惩罚或奖励的预期）。由于理性人会通过比较成本与收益做出决策，所以他们会对激励做出反应 1.2 人们如何互相影响原理五：贸易可以使每个人的情况都变得更好贸易可以使得每个人做自己擅长的活动。通过与其他人贸易，人们可以以较低的成本获得各种各样的物品与服务。 原理六：市场通常是组织经济活动的一种 好方法市场经济：许多家庭和企业在物品与服务市场上互相交易时，通过他们的分散决策配置资源的经济。 家庭和企业在市场上互相交易，他们仿佛被一只“看不见的手”所指引，并导致了合意的市场结果。 原理七：政府优势可以改善市场的结果看不见的手是强有力的，但并不是无所不能的。政府干预经济并改变人们自己选择的资源配置的原因有两类：促进效率或促进平等。也就是说，大多数政策目标是要么把经济蛋糕做大，要么改变这个蛋糕的分割方式。 1.3 整体经济如何运行原理八：一国的生活水平取决于它生产物品与服务能力生活水平的差别可以归结于生产率的差别，即每一单位劳动投入所生产的物品与服务数量的差别。 原理九：当政府发行了过多的货币时，物价上升通货膨胀是物价总水平的上升。大多数严重或者持续的通货膨胀情况下，罪魁祸首是货币的增长。 原理十：社会面临通货膨胀与失业之间的短期权衡取舍长期中，物价水平的上升主要是货币量增加的结果 货币注入的短期效应： 经济中货币的增加刺激了社会的整体支出水平，从而增加了对物品和服务的需求 需求的增加随着时间的推移，会引起企业提高物价，但同时，它也鼓励企业雇佣更多的工人，并生产更多的物品与服务 雇佣更多的工人意味着更少的失业 二、参考文献【0】经济学原理 微观经济学分册","tags":[{"name":"经济学","slug":"经济学","permalink":"https://www.delta1037.cn/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"}]},{"title":"C++ 类型转换","date":"2020-04-24T16:00:00.000Z","path":"2020/C_C++/C++类型转换/","text":"C++中的const_cast、static_cast、dynamic_cast和reinterpret_cast C++类型转换典型的C类型转换如下所示 text12Typename_1 var_type_1;Typename_0 var_type_0 = (Typename_0)var_type_1; 在C语言中，不管什么类型的转换都可以使用上述的形式；C++也支持上述类型的强制类型转换，但是这种转换可能会带来一些隐患，所以C++提供了四个在不同场合的强制类型转换函数：const_cast, static_cast, dynamic_cast, reinterpret_cast 一、const_castconst_cast用于修改指针或者引用，将指针或引用的常量形式转为非常量的形式，并且仍然指向原来的对象 SUM： 修改指针或者引用 常量转为非常量 Code： text1234567891011121314151617# 正常的使用方法int test_func()&#123; int num = 6; const int *p_const_num = &amp;num; int *p_num = const_cast&lt;int*&gt;p_const_num; *p_num = 8; return 0;&#125;# 未定义的使用方法int test_func()&#123; const char *p_const_str = &quot;ABCD&quot;; char *p_str = const_cast&lt;char*&gt;p_const_str; return 0;&#125; 二、static_caststatic_cast与C语言风格的强制转换效果一样 SUM： 常用于： 类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 基本数据类型之间的转换，如把int转换成char，把int转换成enum。安全性需要开发者来维护 注： 没有运行时检查，与C风格一样都存在安全隐患 static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除) c++ 的任何的隐式转换都是使用 static_cast 来实现 Code： text1234567891011121314151617class Base&#123; // base class&#125;;class Sub : public Base&#123; // sub class&#125;;// 继承类向基类的转换，编译通过并且是安全的Sub sub;Base *base_ptr = static_cast&lt;Base*&gt;sub;// 基类向继承类的转换，编译通过但是是不安全的Base base;Sub *sub_ptr = static_case&lt;Sub*&gt;base; 三、dynamic_castdynamic_cast将基类指针（或引用）转换成继承类指针（或引用），dynamic_cast会根据基类指针是否真正指向继承类指针做相应处理。 text1234567891011121314151617181920212223242526272829303132333435363738394041424344class Base&#123;public: virtual void print()&#123; cout &lt;&lt; &quot;base class print&quot; &lt;&lt; endl; &#125;&#125;;class Sub : public Base &#123;public: void print() override&#123; cout &lt;&lt; &quot;sub class print&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Sub *sub_ptr = new Sub(); sub_ptr-&gt;print(); // 如果基类没有虚函数，使用dynamic_cast会报错 Base *base_ptr = dynamic_cast&lt;Base*&gt;(sub_ptr); if(base_ptr)&#123; base_ptr-&gt;print(); &#125;else&#123; cout &lt;&lt; &quot;base ptr is NULL&quot; &lt;&lt; endl; &#125; delete sub_ptr; base_ptr = new Base(); base_ptr-&gt;print(); sub_ptr = dynamic_cast&lt;Sub*&gt;(base_ptr); if(sub_ptr)&#123; sub_ptr-&gt;print(); &#125;else&#123; cout &lt;&lt; &quot;sub ptr is NULL&quot; &lt;&lt; endl; &#125; delete base_ptr; return 0;&#125;/* Win10上的Clion输出如下: sub class print sub class print base class print sub ptr is NULL*/ 从上边的运行结果可以看出： 从子类到基类的指针dynamic_cast转换没有问题 从基类到子类的转换虽然编译没有报错，但是转换的sub_ptr是一个空指针，说明dynamic_cast在程序运行时对类型进行了检查（RTTI，运行期类型检查，Runtime type information） 这个检查主要来自虚函数，虚函数时dynamic_cast转换能够进行的前提条件。当一个类有一个虚函数，那么编译器会构造出来一个虚函数表来指示这些虚函数的地址，如果该类被继承并且子类实现了一个同名并具有相同的函数签名的方法重写了基类的方法，那么虚函数表中会将该函数指向新的地址。此时多态性体现：使用激烈的指针或引用指向子类的对象，调用该方法时会顺着虚函数表找到对应子类的方法。 四、reinterpret_castreinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较底层的重新解释。 主要应用在： 任意指针之间的转换 引用之间的转换 指针和足够大的int类型之间的转换 整数到指针的转换 text123456789101112int main() &#123; int *num_ptr = new int(2333); uint64_t ptr_num = reinterpret_cast&lt;uint64_t&gt;(num_ptr); cout &lt;&lt; &quot;ptr addr :&quot; &lt;&lt; hex &lt;&lt; num_ptr &lt;&lt; endl &lt;&lt; &quot;num val :&quot; &lt;&lt; hex &lt;&lt; ptr_num &lt;&lt; endl; return 0;&#125;/*64位机器上的测试和输出 ptr addr :0x80004adc0 num val :80004adc0*/ 参考【0】c++ 四种强制类型转换介绍 【1】C++虚函数表剖析 【2】dynamic_cast","tags":[{"name":"C++","slug":"C","permalink":"https://www.delta1037.cn/tags/C/"}]},{"title":"MySQL使用MariaDB Audit Plugin实现审计功能","date":"2019-10-19T16:00:00.000Z","path":"2019/Deploy/MySQL使用MariaDBAuditPlugin实现审计功能/","text":"MySQL使用MariaDB Audit Plugin实现审计功能。 一、安装MariaDB Audit Plugin1.1 准备MariaDB安装环境为了不对使用mysql的主机造成影响，建议使用另一台与mysql主机系统一致的主机来安装MariaDB，然后不用执行下面的卸载操作 text123sudo apt-get autoremove --purge mysql-\\*sudo rm -rf /var/lib/mysql*sudo rm -rf /etc/mysql/ 1.2 安装MariaDBtext1sudo apt-get install mariadb-server 安装完成之后在&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin目录中有server_audit.so插件，将该插件拷贝出来备用（拷贝到mysql主机的&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin目录中） 1.3 MySQL环境恢复如果是在mysql的主机上进行安装MariaDB操作，使用如下命令将MariaDB卸载，并重新安装mysql text12345sudo apt-get remove --purge mariadb-\\*sudo rm -rf /etc/mysql/sudo rm -rf /var/lib/mysql*sudo apt-get remove --purge mysql-\\*sudo apt-get install mysql-server mysql-client 1.4 添加MySQL配置修改&#x2F;etc&#x2F;mysql&#x2F;my.cnf文件，在文件末尾添加如下内容 text12345[mysqld]log_output=FILEserver_audit_file_path=/var/log/mysql/audit.logserver_audit_events = &#x27;QUERY_DCL,QUERY_DML_NO_SELECT,QUERY_DML,QUERY_DDL,TABLE,QUERY,CONNECT&#x27;server_audit_logging=1 重新启动MySQL text1service mysql restart 二、Mysql审计日志分析2.1 server_audit_events变量过滤功能使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下 text1set global server_audit_events=&#x27;QUERY_DDL&#x27;; 执行如下SQL语句 text12345create database test2;use test2;create table table1 (col1 VARCHAR(20));insert into table1 values (&quot;lili&quot;);select * from table1; text1220191019 20:56:50,delta-mysql,root,localhost,16,1300,QUERY,test,&#x27;create database test2&#x27;,020191019 20:57:29,delta-mysql,root,localhost,16,1306,QUERY,test2,&#x27;create table table1 (col1 VARCHAR(20))&#x27;,0 由上图可见只有create类型的日志被记录下来，insert和select类型的操作日志并没有被记录下来，并且操作类型字段显示为QUERY类型 使用mysql -uroot -p登陆数据库，执行如下命令修改变量为如下 text1set global server_audit_events=&#x27;QUERY_DDL,QUERY_DML&#x27;; text12345create database test3;use test3;create table table2 (col1 VARCHAR(20));insert into table2 values (&quot;lili&quot;);select * from table2; 前两行是上面的日志，后面的是新产生的日志 text12345678910111220191019 20:56:50,delta-mysql,root,localhost,16,1300,QUERY,test,&#x27;create database test2&#x27;,020191019 20:57:29,delta-mysql,root,localhost,16,1306,QUERY,test2,&#x27;create table table1 (col1 VARCHAR(20))&#x27;,020191019 21:45:18,delta-mysql,root,localhost,16,1312,QUERY,test2,&#x27;create table table2 (col1 VARCHAR(20))&#x27;,020191019 21:45:33,delta-mysql,root,localhost,16,1313,QUERY,test2,&#x27;insert into table2 values (&quot;lili&quot;)&#x27;,020191019 21:45:56,delta-mysql,root,localhost,16,1314,QUERY,test2,&#x27;select * from table2&#x27;,020191019 21:47:52,delta-mysql,root,localhost,16,1316,QUERY,test2,&#x27;create databse test3&#x27;,106420191019 21:47:58,delta-mysql,root,localhost,16,1317,QUERY,test2,&#x27;create database test3&#x27;,020191019 21:48:08,delta-mysql,root,localhost,16,1318,QUERY,test2,&#x27;SELECT DATABASE()&#x27;,020191019 21:48:15,delta-mysql,root,localhost,16,1320,QUERY,test2,&#x27;SELECT DATABASE()&#x27;,020191019 21:48:31,delta-mysql,root,localhost,16,1324,QUERY,test3,&#x27;create table table2 (col1 VARCHAR(20))&#x27;,020191019 21:48:31,delta-mysql,root,localhost,16,1325,QUERY,test3,&#x27;insert into table2 values (&quot;lili&quot;)&#x27;,020191019 21:48:31,delta-mysql,root,localhost,16,1326,QUERY,test3,&#x27;select * from table2&#x27;,0 由上可见，create，select和insert类型的日志均被记录下来，并且操作类型字段均为QUERY类型，并不是QUERY_DDL和QUERY_DML类型 根据官方文档显示，QUERY_DDL操作类型指的是进行CREATE等操作时才产生QUERY_DDL操作类型的日志，QUERY_DML操作类型是进行SELECT等操作时才产生QUERY_DML操作类型的日志。 综上所述，server_audit_events确实对操作日志起到了过滤作用，但是实际日志中操作类型字段只有QUERY。说明QUERY_DDL确实起到了日志类型过滤作用，实际操作类型字段仍为QUERY。 2.2TABLE Event分析按照官方文档显示，执行查询操作时会显示操作类型为READ的TABLE事件日志 text12345620170817 16:04:33,ip-172-30-0-38,root,localhost,29,913,READ,company,employees,20170817 16:04:33,ip-172-30-0-38,root,localhost,29,913,READ,company,employees_salaries,20170817 16:04:33,ip-172-30-0-38,root,localhost,29,913,READ,company,ref_job_titles,20170817 16:04:33,ip-172-30-0-38,root,localhost,29,913,READ,company,org_departments,20170817 16:04:33,ip-172-30-0-38,root,localhost,29,913,QUERY,company,&#x27;SELECT * FROM employee_pay WHERE title LIKE \\&#x27;%Executive%\\&#x27; OR title LIKE \\&#x27;%Manager%\\&#x27;&#x27;,0 下面是在MySQL中执行查询操作产生的audit日志，由最后一条可以看出，并没有READ类型的操作日志。 text1220191020 10:48:09,delta-mysql,root,localhost,3,31,QUERY,wordpress,&#x27;SELECT * FROM wp_options WHERE option_name LIKE \\&#x27;%Executive%\\&#x27; OR title LIKE \\&#x27;%Manager%\\&#x27;&#x27;,105420191020 10:48:19,delta-mysql,root,localhost,3,32,QUERY,wordpress,&#x27;SELECT * FROM wp_options WHERE option_name LIKE \\&#x27;%Executive%\\&#x27; OR option_name LIKE \\&#x27;%Manager%\\&#x27;&#x27;,0 通过查询资料，TABLE事件只支持MariaDB 5.5.31 以及更新的版本，MySQL Server不提供MariaDB Audit Plugin需要的信息来追踪TABLE事件。 三、参考资料MariaDB Audit Plugin 官方文档MYSQL-MARIADB AUDIT PLUGIN INSTALLATION AND CONFIGURATION","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.delta1037.cn/tags/MySQL/"}]},{"title":"CentOS 6安装GitLab服务端","date":"2019-10-17T16:00:00.000Z","path":"2019/Deploy/CentOS6安装GitLab服务端/","text":"CentOS 6安装GitLab服务端 一、配置基础环境text1234yum install openssh-serveryum install postfixservice postfix startchkconfig postfix on 二、下载安装gitlabgitlab安装包下载地址：centos 6系统的下载地址:https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6centos 7系统的下载地址:https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7安装： text1rpm -i gitlab-ce-9.5.9-ce.0.el6.x86_64.rpm 三、配置gitlab修改gitlab配置文件指定服务器ip和自定义端口，将external_url后面的值修改为http://ip:port（例如http://192.168.7.89:8010，如果不指定端口则是默认的端口80） text1vim /etc/gitlab/gitlab.rb 如果服务端开启了防火墙，则需要开放相应的端口 text1iptables -I INPUT -p tcp --dport 8010 -j ACCEPT 按照新的配置文件重新配置gitlab，并重新启动 text12gitlab-ctl reconfiguregitlab-ctl restart 查看gitlab运行状态 text1234567891011121314151617gitlab-ctl status# 得到如下输出run: gitaly: (pid 10798) 24009s; run: log: (pid 4490) 24327srun: gitlab-monitor: (pid 10820) 24009s; run: log: (pid 5099) 24297srun: gitlab-workhorse: (pid 10824) 24008s; run: log: (pid 4654) 24321srun: logrotate: (pid 24622) 2407s; run: log: (pid 4894) 24309srun: nginx: (pid 10887) 24007s; run: log: (pid 4803) 24315srun: node-exporter: (pid 10896) 24007s; run: log: (pid 5007) 24303srun: postgres-exporter: (pid 10908) 24006s; run: log: (pid 5383) 24279srun: postgresql: (pid 10918) 24006s; run: log: (pid 3780) 24391srun: prometheus: (pid 10926) 24005s; run: log: (pid 5271) 24285srun: redis: (pid 10943) 24005s; run: log: (pid 3615) 24398srun: redis-exporter: (pid 10947) 24005s; run: log: (pid 5181) 24291srun: sidekiq: (pid 10959) 24004s; run: log: (pid 4393) 24333srun: unicorn: (pid 10987) 24003s; run: log: (pid 4292) 24339s bug0:&#96;GLIBC_2.14’ not found如果出现报错&#x2F;lib64&#x2F;libc.so.6: version &#96;GLIBC_2.14’ not found，则需要升级glibc text1234567891011121314# 下载安装包wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gztar zxvf glibc-2.14.tar.gzcd glibc-2.14mkdir buildcd build# 编译安装../configure --prefix=/opt/glibc-2.14make -j4make install# 设置链接库目录export LD_LIBRARY_PATH=/opt/glibc-2.14/lib","tags":[{"name":"GitLab","slug":"GitLab","permalink":"https://www.delta1037.cn/tags/GitLab/"}]},{"title":"Install Oracle Database 9i on CentOS 5 (i386)","date":"2019-10-13T16:00:00.000Z","path":"2019/Deploy/InstallOracleDatabase9ionCentOS5(i386)/","text":"Oracle Database 9i的官方安装环境为RHEL3，RHEL4。由于项目需要，需要同时安装Oracle Database 9i和日志采集工具rsyslog，rsyslog仅支持RHEL&#x2F;CENTOS 5及其以上的版本，最终在CentOS 5 (i386)版本上安装成功。 一、软件下载： Oracle9i Database Release 2 Enterprise&#x2F;Standard Edition for Intel Linux（ship_9204_linux_disk）：迅雷 百度网盘提取码：ve9y 补丁： compat-libcwait-2.1-1.i386.rpm compat-oracle-rhel4-1.0-5.i386.rpm j2re-1_3_1_19-linux-i586.bin 二、开始安装1、关闭SELinuxtext12gedit /etc/selinux/configset SELINUX=disabled 2、 安装JREtext123chmod +x j2re-1_3_1_19-linux-i586.bin./j2re-1_3_1_19-linux-i586.binmv jre1.3.1_19 /usr/local/ 3、安装缺少的依赖text1234567891011121314151617181920# 检查依赖缺失rpm -q compat-db compat-gcc-34 compat-gcc-34-c++ \\ compat-libgcc-296 compat-libstdc++-296 compat-libstdc++-33 \\ gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers libgcc make libXp# 使用yum安装依赖yum install compat-db*yum install compat-gcc*yum install gcc*yum install compat-libgcc*yum install compat-libstdc++*yum install gnome-libs*yum install libaio*yum install openmotif*yum install xorg-x11-deprecated-libs*yum install glibc-devel*# 安装补丁rpm -Uvh compat-libcwait-2.1-1.i386.rpmrpm -Uvh compat-oracle-rhel4-1.0-5.i386.rpm --nodeps 4、配置环境text123456cd /usr/libln -s libstdc++-3-libc6.2-2-2.10.0.so libstdc++-libc6.1-1.so.2ln -s libgdbm.so.2.0.0 libdb.so.2cd /usr/binln -s gcc34 gcc32 5、添加oracle组和用户text1234groupadd oinstall #添加oinstall组groupadd dba # 添加dba组useradd -g oinstall -G dba oracle #新建用户并添加到组passwd oracle #按照输出设置密码 6、建立安装目录text123456cd /optmkdir oracle # 创建oracle目录chown –R oracle.oinstall oracle #修改oracle目录权限cd oraclemkdir 920 # 创建9i安装目录 7、 配置环境变量和系统设置以oracle用户登陆，打开&#x2F;u01&#x2F;oracle&#x2F;.bash_profile，在文件末尾追加如下内容 text1234567891011121314ORACLE_BASE=/opt/oracle; export ORACLE_BASEORACLE_HOME=$ORACLE_BASE/920; export ORACLE_HOMEORACLE_SID=orcl; export ORACLE_SIDLD_LIBRARY_PATH=$ORACLE_HOME/lib; export LD_LIBRARY_PATHORACLE_OEM_JAVARUNTIME=/usr/local/jre1.3.1_19; export ORACLE_OEM_JAVARUNTIMEPATH=$PATH:$ORACLE_HOME/bin; export PATHif [ $USER = &quot;oracle&quot; ]; then if [ $SHELL = &quot;/bin/ksh&quot; ]; then ulimit -p 16384 ulimit -n 65536 else ulimit -u 16384 -n 65536 fifi 以root用户登陆，打开&#x2F;etc&#x2F;sysctl.conf，在文件末尾追加如下内容，并执行sysctl -p生效 text12345678kernel.shmmni = 4096kernel.sem = 250 32000 100 128fs.file-max = 65536net.ipv4.ip_local_port_range = 1024 65000net.core.rmem_default=262144net.core.wmem_default=262144net.core.rmem_max=262144net.core.wmem_max=262144 打开&#x2F;etc&#x2F;security&#x2F;limits.conf，在文件末尾追加如下内容 text1234oracle soft nofile 65536oracle hard nofile 65536oracle soft nproc 16384oracle hard nproc 16384 8、文件准备a）从网上下载oracle Database 9i有三个文件 text123ship_9204_linux_disk1.cpio.gzship_9204_linux_disk2.cpio.gzship_9204_linux_disk3.cpio.gz b）对压缩文件解压 text123gunzip ship_9204_linux_disk1.cpio.gzgunzip ship_9204_linux_disk2.cpio.gzgunzip ship_9204_linux_disk3.cpio.gz c）使用如下命令解压得到Disk1、Disk2和Disk3文件夹 text123cpio -idmv &lt; ship_9204_linux_disk1.cpiocpio -idmv &lt; ship_9204_linux_disk2.cpiocpio -idmv &lt; ship_9204_linux_disk3.cpio 9、 开始安装进入Disk1目录，执行.&#x2F; runInstaller开始图形界面的安装程序，选择自己喜欢的版本进行安装，一路next就可以 备注：1、终端界面可能出现Inside isCluster, bCluster bfr return is : false，不影响后续使用2、在最后的configuration阶段会发生错误如下 此时退出安装程序，进行如下操作 text1234567cd $ORACLE_HOMErm JREln -s $ORACLE_BASE/jre/1.3.1 JREcd JRE/binln -s java jrecd i386/native_threads/ln -s java jre 然后再执行.&#x2F; runInstaller走一遍安装流程即可 三、使用1、建立数据库进入&#x2F;u01&#x2F;oracle&#x2F;product&#x2F;bin目录，运行dbca命令，进入建立数据库的图形界面，根据界面提示进行操作 2、使用过程中可能会遇到的问题a）startup 出现LRM-00109: could not open parameter file …： text12cd /opt/oracle /admin/sxf/pfile #sxf是dbca新建的数据库名cp init.ora.* /opt/oracle/920/dbs/initmyoracle.ora b）startup出现ORA-01990: error opening password file ‘&#x2F;opt&#x2F;oracle&#x2F;920&#x2F;dbs&#x2F;orapw’ text12cd /opt/oracle/920/binorapwd file=/opt/oracle/920/dbs/orapw passwd=sxf123 entries=1024 四、个人经验1、以CentOS 5（x86_64）无法完成amd64_db_9204_Disk1.cpio.gz的安装2、以CentOS 4（x86_64）可以完成amd64_db_9204_Disk1.cpio.gz的安装 五、参考文献1、Installing Oracle 9i on RHEL5. (x86)","tags":[{"name":"部署","slug":"部署","permalink":"https://www.delta1037.cn/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"点石成金，挥刀琢玉——“双创老太”刘玉那些事儿","date":"2019-08-20T16:00:00.000Z","path":"2019/DianGroup/点石成金，挥刀琢玉——“双创老太-刘玉那些事儿/","text":"点石成金，挥刀琢玉——“双创老太”刘玉那些事儿 高调、爱折腾、不走寻常路、犀利、“毒舌”、超级大忙人，她是被贴满标签的华中大教授——刘玉老师。而其中最响亮，最广为人知的标签，一定非“双创老太”莫属。今天，让我们走近这神秘的刘玉教授，说一说，她的那些事儿—— 她是谁—— 湖北省创业红娘众创空间 负责人 武汉创业红娘公益服务中心 理事长 华中科技大学 电信学院 教 授 华中科技大学 Dian团队 创始人 她都做过什么—— 扶弟子创新 曾指导本科生获全国挑战杯特等奖，Dian团队育人模式获国家教学成果二等奖，教育部大学生创新性实验计划的“源头”之一，央视小崔说事栏目曾以“点亮未来”专题报道，曾应邀到全国高校、中学、企事业等逾百家单位作创新创业报告，引起强烈反响。曾获评“全国师德先进个人”和湖北省“五一劳动奖章”、湖北省教育系统“三育人”奖、 宝钢优秀教师特等奖的提名奖、两次获华中科技大学教学质量优秀一等奖。 在她严格要求和精心培养下，Dian团队出站队员500多人在社会上总体表现优异，近7年涌现出50余家创业公司，其中贝贝网和贝店已成为独角兽，释码大华、ping++、悦然心动等创业公司业绩斐然，4人荣登福布斯中国30位“30岁以下创业者”榜单。 帮他人创业 2015年3月，刘玉创办“武汉市洪山区创业红娘公益服务中心”，义务为优秀创业项目与投资机构牵线搭桥，创业项目的甄选范围从华中科技大学在校生拓宽至全社会，不分地域、不分年龄、不分学校、不分学历。至今，经刘玉老师推荐的创业项目已超过500个，融资成交率13.2%，促成投资总额2.57亿元。 她的那些事儿—— 刘玉:创客点睛手——《长江日报》 创新潜能在实践中尽情释放——《中国教育报》网络版 人民网专访“创业红娘”刘玉：如何做到人靠谱、事落实、有情怀 刘玉：被“强推转身”的创业红娘——《中国青年报》 全国布撒“姻缘线”的“创业红娘” ——武汉首个创业服务公益机构实录——《长江日报》 武汉女教授入选“中国好人” 免费孵出50多家公司——荆楚网 华科Dian团队15年走出10余家“过亿”企业——人民网 崔永元“说事”设“圈套” 女教授均“化险为夷”——中国政协新闻网 “点”下种子——访谈华中科技大学“点团队”创始人刘玉教授——《大学生》 华科创客点睛手刘玉讲述：张小龙在武汉首提微信产品观——荆楚网 刘延东寄语Dian团队———在实践中释放创新潜能 华中科大教授刘玉：人才标准固化扼杀大学生创新热情——《中国青年报》 华中科技大学刘玉教授：未来工程师“点”亮江城","tags":[{"name":"Dian","slug":"Dian","permalink":"https://www.delta1037.cn/tags/Dian/"}]},{"title":"编译总结","date":"2019-08-02T16:00:00.000Z","path":"2019/C_C++/编译总结/","text":"C&#x2F;C++编译流程梳理 一、系统环境 CPU：Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz 操作系统：Ubuntu 18.04.2 LTS 内核版本：Linux version 4.18.0-25-generic GNU GCC版本：gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1) C standard revision：C11 GNU Compiled BY GMP version： 6.1.2 MPFR version ：4.0.1 MPC version ： 1.1.0 isl version ： isl-0.19-GMP GNU 汇编器版本：2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30 链接器版本： collect2 version：7.4.0 gcc一般是collect2,而不是ld，collect2 是ld链接器的一个封装，最终还是调用ld来完成链接工作 collect2通过第一次链接程序查看链接器输出文件来查找具有特定名称表明是构造函数的符号，如果找得到则会创建一个新的临时‘.c’文件包含这些符号，然后编译这个文件并第二次链接程序.The program collect2 works by linking the program once and looking through the linker output file for symbols with particular names indicating they are constructor functions. If it finds any, it creates a new temporary ‘.c’ file containing a table of them, compiles it, and links the program a second time including that file.） GNU ld (GNU Binutils for Ubuntu)：2.30 二、GCC编译过程2.1 GCC编译过程 预处理 删除所有的#define，展开所有的宏定义 处理所有的条件预编译指令&lt;#if,#endif,#ifdef,#ifndef,#elif,#else&gt; 处理#include预编译指令，将包含的文件插入到include的位置（递归进行） 删除所有的注释 添加行号和文件名标识（调试时使用） 保留所有的#pragma编译器指令（编译器需要使用这些指令） text1234567# 单独产生预处理后的文件（本模块假设hello.c是源代码程序,hello.i是hello.c预处理后的文件,hello.s是hello.c编译后的文件，hello.o是hello.c汇编后的文件，hello是hello.c最终的可执行程序）# 使用gcc命令产生预处理文件$ gcc -E hello.c -o hello.i# 使用cpp命令产生预处理文件$ cpp hello.c &gt; hello.i 编译：将预处理完的文件进行一系列的词法分析、语法分析、语义分析、中间代码生成、目标代码生成与优化之后产生相应的汇编代码文件 词法分析：扫描器运行类似于有限状态机的算法将代码的字符序列分割成一系列的记号 语法分析：语法分析器对扫描器产生的记号进行语法分析，从而产生语法树（以表达式为节点的树） 语义分析：语义分析器确定语句的意义（比如两个指针做乘法是没有意义的），编译器只能分析静态语义（在编译时能够确定的语义，通常包括声明和类型的匹配，类型的转换；与之相对的动态语义是在运行时才能确定的语义，例如将0作为除数是一个运行期语义错误） text12345678# 编译预处理后的文件产生汇编代码文件$ gcc -S hello.i -o hello.s# 编译源文件产生汇编代码文件$ gcc -S hello.c -o hello.s# 现在的gcc编译器将预处理和编译两个步骤合成了一个步骤，使用一个叫cc1的程序来完成这个过程$ /usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o hello.s 汇编：将汇编代码转变成机器可以执行的指令（根据汇编指令和机器指令的对照表一一翻译） text12345678# 使用as处理汇编文件产生目标文件$ as hello.s -o hello.o# 使用gcc处理汇编文件产生目标文件$ gcc -c hello.s -o hello.o# 使用gcc处理源文件产生目标文件$ gcc -c hello.c -o hello.o 链接：将目标文件链接到一起形成可执行文件,主要包括地址和空间分配，符号决议，和重定位等步骤 符号决议：也叫做符号绑定、名称绑定、名称决议等等。从细节上来讲，决议更倾向于静态链接，绑定更倾向与动态链接 重定位：编译一个文件时不知道一个要调用的函数或者需要操作的一个变量的地址，就会把这些调用函数或者操作变量的指令目标地址搁置，等到最后链接的时候由链接器去将这些指令的目标地址修正，这个地址修正的过程也被叫做重定位，每一个需要修正的地方叫做重定位入口。 2.2 实际编译过程 使用如下样例，包含hello.c和func.c两个源文件（之后也是用这两个文件进行分析） text123456789101112131415161718192021222324252627282930313233343536373839/* hello.c：主测试程序，包括全局静态变量，局部静态变量，全局变量，局部变量，基本的函数调用 */// export varextern int export_func_var;// global varint global_uninit_var;int global_init_var_0 = 0;int global_init_var_1 = 1;// const varconst char *const_string_var = &quot;const string&quot;;// static global varstatic int static_global_uninit_var;static int static_global_init_var_0 = 0;static int static_global_init_var_1 = 1;// func headervoid func_call_test(int num);int main(void)&#123; // local var int local_uninit_var; int local_init_var_0 = 0; int local_init_var_1 = 1; // static local var static int static_local_uninit_var; static int static_local_init_var_0 = 0; static int static_local_init_var_1 = 1; // call func func_call_test(8); // export var op export_func_var = export_func_var * 2; return 0;&#125; text123456/* func.c：包含一个简单的被调用函数和一个全局变量 */int export_func_var = 666;void func_call_test(int num)&#123; int double_num = num * 2;&#125; 使用gcc -v hello.c func.c编译生成可执行文件a.out，产生如下输出（简化版本） text1234567891011121314[delta@delta: code ]$ gcc -v func.c hello.c# 对func.c的预处理和编译过程/usr/lib/gcc/x86_64-linux-gnu/7/cc1 func.c -o /tmp/ccfC6J5E.s# 对func.c产生的.s文件汇编产生二进制文件as -v --64 -o /tmp/ccF4Bar0.o /tmp/ccfC6J5E.s# 对hello.c的预处理和编译过程/usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o /tmp/ccfC6J5E.s# 对hello.c产生的.s文件汇编产生二进制文件as -v --64 -o /tmp/cc7UmhQl.o /tmp/ccfC6J5E.s# 链接过程/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -dynamic-linker ld-linux-x86-64.so.2 Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o 三、链接过程解析Q: 目标文件的格式是怎样的？ 多个目标是如何链接到一起的？ 3.1 目标文件3.1.1目标文件类型 Window下的PE（Portable Executable） Linux下的ELF（Executable Linkable Format） 1、PE和ELF格式都是COFF（Common file format）格式的变种2、目标文件与可执行文件的内容和结构类似，所以一般采用相同的格式存储。广义上来可以将目标文件和可执行文件看做是同一种类型的文件，在window下统称它们为PE-COFF文件格式，在Linux下统称它们为ELF文件。3、不止是可执行文件按照可执行文件格式存储，动态链接库（DLL，Dynamic Linking Library）（Window的.dll和Linux的.so）以及静态链接库（Static Linking Library）（Window的.lib和Linux的.a）文件都按照可执行文件的格式存储。（静态链接库稍有不同，它是把很多的目标文件捆绑在一起形成一个文件，再加上一些索引。可以理解为一个包含很多目标文件的文件包） 3.1.2 ELF文件类型 ELF文件类型 说明 实例 可重定位文件（Relocatable File） 包含代码和数据，可以被用来链接成可执行文件或者共享目标文件，静态链接库可以归为这一类 Linux的.o，Window下的.obj 可执行文件（Executable File） 包含可以直接执行的程序，一般没有扩展名 Linux的&#x2F;bin&#x2F;bash文件，Window的.exe 共享目标文件（Shared Object File） 包含代码和数据，链接器可以上映这种文件与其他可重定位文件和共享目标文件进行链接产生新的目标文件；动态链接器可以将几个共享目标文件与可执行文件结合，作为进程映像的一部分来运行 Linux的.so，Window的.dll 核心转储文件（Core Dump File） 进程意外终止时，系统将该进程的地址空间的内容以及终止时的其它信息转储到核心转储文件 Linux下的core dump 3.1.3目标文件结构目标文件中包含编译后的指令代码、数据，还包括了链接时需要的一些信息（符号表，调试信息和字符串等），一般目标文件将这些信息按照不同的属性，以节（Section）的形式存储（有时也称为**段（Segment)**）。如下图所示 3.1.3.1****常见的段 段名 说明 .text&#x2F;.code 代码段，编译后的机器指令 .data 数据段，全局变量和局部静态变量 .bss 未初始化的全局变量和局部静态变量（.bss段只是为未初始化的全局变量和局部静态变量预留位置） .rodata 只读信息段 .rodata1 存放只读数据，字符串常量，全局const变量。与.rodata一样 .comment 编译器版本信息 .debug 调试信息 .dynamic 动态链接信息 .hash 符号哈希表 .line 调试时的行号表，即源代码行号与编译后的指令的对应表 .note 额外的编译器信息。程序的公司名，发布版本号 .strtab String Table，字符串表，用来存储ELF文件中用到的各种字符串 .symtab Symbol Table，符号表 .shstrtab Section String Table，段名表 .plt&#x2F;.got 动态链接的跳转表和全局入口表 .init&#x2F;.fini 程序初始化与终结代码段 3.1.3.2目标文件结构分析 ELF文件头： 使用gcc -c hello.c -o hello.o生成目标文件hello.o，并使用readelf -h hello.o读取目标文件的ELF文件头，可以看出ELF文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本，运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序入口和长度、段表的位置和长度及段的数量等，如下图所示 text1234567891011121314151617181920ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#x27;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 1328 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 15 Section header string table index: 14 ELF文件头结构体定义在&#x2F;usr&#x2F;include&#x2F;elf.h中，目标文件hello.o的文件头中机器字节长度为ELF64，找到64位版本文件头结构体Elf64_Ehdr定义，如下所示 text1234567891011121314151617typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */&#125; Elf64_Ehdr; 除结构体中的e_ident对应到readelf输出的从Magic到ABI Version部分，其它都是一一对应关系 e_shstrndx变量表示.shstrtab在段表中的下标 段表 使用gcc -c hello.c -o hello.o生成目标文件hello.o，并使用readelf -S hello.o读取目标文件的段表部分 text1234567891011121314151617181920212223242526272829303132333435363738Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000035 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000440 0000000000000048 0000000000000018 I 12 1 8 [ 3] .data PROGBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 00000084 0000000000000014 0000000000000000 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 00000084 000000000000000d 0000000000000000 A 0 0 1 [ 6] .data.rel.local PROGBITS 0000000000000000 00000098 0000000000000008 0000000000000000 WA 0 0 8 [ 7] .rela.data.rel.lo RELA 0000000000000000 00000488 0000000000000018 0000000000000018 I 12 6 8 [ 8] .comment PROGBITS 0000000000000000 000000a0 000000000000002c 0000000000000001 MS 0 0 1 [ 9] .note.GNU-stack PROGBITS 0000000000000000 000000cc 0000000000000000 0000000000000000 0 0 1 [10] .eh_frame PROGBITS 0000000000000000 000000d0 0000000000000038 0000000000000000 A 0 0 8 [11] .rela.eh_frame RELA 0000000000000000 000004a0 0000000000000018 0000000000000018 I 12 10 8 [12] .symtab SYMTAB 0000000000000000 00000108 0000000000000240 0000000000000018 13 16 8 [13] .strtab STRTAB 0000000000000000 00000348 00000000000000f6 0000000000000000 0 0 1 [14] .shstrtab STRTAB 0000000000000000 000004b8 0000000000000076 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) 段表结构体定义在&#x2F;usr&#x2F;include&#x2F;elf.h中，目标文件hello.o的文件头中机器字节长度为ELF64，找到64位版本段表结构体定义Elf64_Shdr（每个Elf64_Shdr对应一个段，Elf64_Shdr又称为**段描述符**），如下所示 text12345678910111213typedef struct&#123; Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr; Elf64_Shdr部分成员解释 变量名 说明 sh_name 段名是一个字符串，位于一个叫.shstrtab的字符串表中，sh_name是段名字符串在.shstrtab中的偏移 sh_addr 段虚拟地址，如果该段可以加载，sh_addr为该段被加载后在进程地址空间的虚拟地址，否则为0 sh_offset 段偏移，如果该段存在于文件中则表示该段在文件中的偏移，否则无意义 sh_link、sh_info 段链接信息，如果该段的类型是与链接相关的，则该字段有意义 sh_addralign 段地址对齐，sh_addralign表示是地址对齐数量的指数，如果sh_addralign为0或者1则该段没有字节对齐要求 sh_entsize 对于一些段包含了一些固定大小的项，比如符号表，则sh_entsize表示每个项的大小 3. 重定位表：hello.o中包含一个.rela.text的段，类型为RELA，它是一个重定位表。链接器在处理目标文件时必须对文件中的某些部位进行重定位，这些重定位信息都记录在重定位表中。对于每个需要重定位的代码段或者数据段，都会有一个相应的重定位表。 4. 字符串表 - .strtab：字符串表，保存普通的字符串，比如符号的名字 - .shstrtab：段表字符串表，保存段表中用到的字符串，比如段名 结论：ELF文件头中的**e_shstrndx变量表示.shstrtab在段表中的下标，e_shoff**表示段表在文件中的偏移，只有解析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件 3.1.4 链接的接口——符号3.1.4.1 符号定义 定义：在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量地址的引用。在链接中，将函数和变量统称为符号（Symbol），函数名或变量名称为符号名（Symbol Name）。 每个目标文件都有一个符号表记录了目标文件中用到的所有符号（每个定义的符号都有一个符号值，对于函数和变量来说，符号值就是它们的地址），常见分类如下 符号类型 说明 定义在本目标文件中的全局符号 可以被其它目标文件引用的符号 在本目标文件中引用的符号，却没有定义在本目标文件中 外部符号（External Symbol） 段名，由编译器产生 它的值就是该段的起始地址 局部符号 只在编译单元内部可见，链接器往往忽略它们 行号信息 目标文件指令与代码行的对应关系，可选 3.1.4.2 符号结构分析 符号表结构：符号表结构体定义在&#x2F;usr&#x2F;include&#x2F;elf.h中，如下所示 text123456789typedef struct&#123; Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */&#125; Elf64_Sym; Elf64_Sym成员解释 变量名 说明 st_name 符号名在字符串表中的下标 st_info 符号类型和绑定信息 st_other 符号可见性 st_shndx 符号所在的段 st_value 符号对应的值 st_size 符号大小 使用gcc -c hello.c -o hello.o生成目标文件hello.o，并使用readelf -s hello.o读取目标文件的符号表部分 text1234567891011121314151617181920212223242526Symbol table &#x27;.symtab&#x27; contains 24 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS hello.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 6 7: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 static_global_uninit_var 8: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 static_global_init_var_0 9: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_global_init_var_1 10: 0000000000000008 4 OBJECT LOCAL DEFAULT 3 static_local_init_var_1.1 11: 000000000000000c 4 OBJECT LOCAL DEFAULT 4 static_local_init_var_0.1 12: 0000000000000010 4 OBJECT LOCAL DEFAULT 4 static_local_uninit_var.1 13: 0000000000000000 0 SECTION LOCAL DEFAULT 9 14: 0000000000000000 0 SECTION LOCAL DEFAULT 10 15: 0000000000000000 0 SECTION LOCAL DEFAULT 8 16: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_uninit_var 17: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_var_0 18: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var_1 19: 0000000000000000 8 OBJECT GLOBAL DEFAULT 6 const_string_var 20: 0000000000000000 53 FUNC GLOBAL DEFAULT 1 main 21: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 22: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND func_call_test 23: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND export_func_var text1234567注： 1. static_global_uninit_var、static_local_init_var_0和static_local_uninit_var、static_global_init_var_0和global_init_var_0在bss段（因为初始化为0和不初始化是一样的） 2. static_global_init_var_1、static_local_init_var_1和global_init_var_1在data段（初始化的全局变量） 3. static变量的类型均为LOCAL，表明该符号只为该目标文件内部可见；非Static全局变量的类型为GLOBAL，表明该符号外部可见 4. 在hello.c中引用了func_call_test和export_func_var符号，但是没有定义，所以它的Ndx是UND（注：export一个变量但是并未使用则符号表中不会出现这个边浪符号信息；export一个不存在的变量但是并未使用编译不会报错；export一个不存在的变量并使用会报错 &lt;**注意系统环境**&gt; ） 5. 未初始化的全局非静态变量global_uninit_var在COM块中 6. const_string_var在.data.rel.local段中 特殊符号：当使用链接器生成可执行文件时，会定义很多特殊的符号，这些符号并未在程序中定义，但是可以直接声明并引用它们 3.1.4.3 符号修饰与函数签名符号修饰与函数签名：在符号名前或者后面加上_修饰符号，防止与库文件和其它目标文件冲突。现在的linux下的GCC编译器中，默认情况下去掉了加上_这种方式，可以通过参数选项打开 C++符号修饰：C++拥有类，继承，重载和命名空间等这些特性，导致符号管理更为复杂。例如重载的情况：函数名相同但是参数不一样。然后就有了符号修饰和符号改编的机制，使用函数签名（包括函数名，参数类型，所在的类和命名空间等信息）来识别不同的函数 C++符号修饰栗子 text1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class C &#123; public: int func(int); class C2 &#123; public: int func(int); &#125;;&#125;;namespace N &#123; int func(int); class C &#123; public: int func(int); &#125;;&#125;int func(int num)&#123; return num;&#125;float func(float num)&#123; return num;&#125;int C::func(int num)&#123; return num;&#125;int C::C2::func(int num)&#123; return num;&#125;int N::func(int num)&#123; return num;&#125;int N::C::func(int num)&#123; return num;&#125;int main()&#123; int int_res = func(1); float float_var = 1.1; float float_res = func(float_var); C class_C; int_res = class_C.func(1); return 0;&#125; 使用g++ -c hello.cpp -o hello_cpp.o编译产生目标文件hello_cpp.o，使用readelf -a hello_cpp.o查看目标文件中的符号表，如下 text1234567891011121314151617181920Symbol table &#x27;.symtab&#x27; contains 18 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS hello.cpp 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 8 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 12 FUNC GLOBAL DEFAULT 1 _Z4funci 10: 000000000000000c 16 FUNC GLOBAL DEFAULT 1 _Z4funcf 11: 000000000000001c 16 FUNC GLOBAL DEFAULT 1 _ZN1C4funcEi 12: 000000000000002c 16 FUNC GLOBAL DEFAULT 1 _ZN1C2C24funcEi 13: 000000000000003c 12 FUNC GLOBAL DEFAULT 1 _ZN1N4funcEi 14: 0000000000000048 16 FUNC GLOBAL DEFAULT 1 _ZN1N1C4funcEi 15: 0000000000000058 119 FUNC GLOBAL DEFAULT 1 main 16: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 17: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND __stack_chk_fail 可以看出函数签名与修饰后的名称的对应关系 函数签名 修饰后名称（符号名） int func(int) _Z4funci float func(float) _Z4funcf int C::func(int) _ZN1C4funcEi int C::C2::func(int) _ZN1C2C24funcEi int N::func(int) _ZN1N4funcEi int N::C::func(int) _ZN1N1C4funcEi extern “C”：C++编译器会将在extern C大括号内的内部代码当做C语言代码处理，也就是名称修饰机制将不会起作用。当需要兼容C和C++，例如在C++代码中调用C中的memset函数，可以使用C++的宏__cplusplus，C++在编译程序时会默认定义这个宏 text123456789#ifdef __cplusplusextern “C” &#123;#endifvoid *memset(void *, int, size_t);#ifdef __cplusplus&#125;#endif 由于不同的编译器采用不同的名字修饰方法，必然会导致不同编译器产生的目标文件无法正常互相链接，这是导致不同编译器之间不能互操作的原因 3.1.4.4 弱符号与强符号在编程中经常遇到符号重定义的问题，例如hello.c和func.c都定义了一个_global并将它们都初始化，在编译时就会报错。对于C&#x2F;C++来说，编译器默认函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号。 编译器处理符号规则 不允许强符号被多次定义 如果一个符号在一个文件中是强符号，在其它文件中是弱符号，则选择强符号 如果一个符号在所有的文件中都是弱符号，则选择其中占用空间最大的一个（int型和double型会选择double型） 弱引用与强引用：对外部目标文件中的符号引用在目标文件最终被链接成可执行文件时都哟啊被正确决议，如果没有找到该符号的定义，则会报未定义错误，这种被称为强引用；与之对应的弱引用，在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器也不会报错。 弱符号与弱引用的作用（对库来说很有用） 库中定义的弱符号可以被用户定义的强符号所覆盖，从而使程序可以使用自定义版本的函数 程序可以对某些扩展功能模块的引用定义为弱引用，当扩展模块与程序链接到一起时，功能模块可以正常使用；如果去掉了某些功能模块，则程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更容易裁剪和组合 3.2 静态链接3.2.1 空间和地址分配链接器在合并多个目标文件的段时，采用相似段合并的方式，并分配地址和空间（虚拟地址空间的分配） 两步链接法： 空间和地址分配：扫描所有的目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表，这一步中，链接器将能够获得所有输入目标文件的段长度，并将它们合并，计算输出文件中各个合并之后的段的长度，建立映射关系。 符号解析与重定位：使用空间和地址分配中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。 当进行了空间和地址分配之后，各个段的虚拟地址也就确定了，由于各个符号在段内的位置是相对的，所以各个符号的地址也就确定了。 3.2.2 符号解析与重定位 使用gcc -c hello.c -o hello.o生成目标文件hello.o，并使用objdump -d hello.o读取目标文件的.text的反汇编结果，如下所示（简略部分内容）；同理使用gcc -c func.c -o func.o生成目标文件func.o。 text12345678910111213141516[delta@rabbit: c_code ]$ objdump -d hello.oDisassembly of section .text:0000000000000000 &lt;main&gt;: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 48 83 ec 10 sub $0x10,%rsp 8: c7 45 f8 00 00 00 00 movl $0x0,-0x8(%rbp) f: c7 45 fc 01 00 00 00 movl $0x1,-0x4(%rbp) 16: bf 08 00 00 00 mov $0x8,%edi 1b: e8 00 00 00 00 callq 20 &lt;main+0x20&gt; 20: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 26 &lt;main+0x26&gt; 26: 01 c0 add %eax,%eax 28: 89 05 00 00 00 00 mov %eax,0x0(%rip) # 2e &lt;main+0x2e&gt; 2e: b8 00 00 00 00 mov $0x0,%eax 33: c9 leaveq 34: c3 retq 分析：由以上结果可以看出，在链接之前，main函数在调用func_call_test函数时，使用的地址是0x00000000，根据反汇编结果就是下一条指令（e8 00 00 00 00之中e8是callq的指令码，00 00 00 00是目的地址相对于下一条指令的偏移量）；在使用export_func_var变量时，编译器就将0x0看做是export_func_var的地址 使用ld hello.o func.o -e main链接两个目标文件，生成可执行文件a.out（并不能执行，因为缺少部分目标文件，但是符号已经被重新定位；e main表示将main函数作为程序入口），使用objdump -d a.out查看a.out的.text段反汇编结果，如下图所示（简略部分内容） text123456789101112131415161718192021222324252627[delta@rabbit: c_code ]$ objdump -d a.outDisassembly of section .text:00000000004000e8 &lt;main&gt;: 4000e8: 55 push %rbp 4000e9: 48 89 e5 mov %rsp,%rbp 4000ec: 48 83 ec 10 sub $0x10,%rsp 4000f0: c7 45 f8 00 00 00 00 movl $0x0,-0x8(%rbp) 4000f7: c7 45 fc 01 00 00 00 movl $0x1,-0x4(%rbp) 4000fe: bf 08 00 00 00 mov $0x8,%edi 400103: e8 15 00 00 00 callq 40011d &lt;func_call_test&gt; 400108: 8b 05 0a 0f 20 00 mov 0x200f0a(%rip),%eax # 601018 &lt;export_func_var&gt; 40010e: 01 c0 add %eax,%eax 400110: 89 05 02 0f 20 00 mov %eax,0x200f02(%rip) # 601018 &lt;export_func_var&gt; 400116: b8 00 00 00 00 mov $0x0,%eax 40011b: c9 leaveq 40011c: c3 retq000000000040011d &lt;func_call_test&gt;: 40011d: 55 push %rbp 40011e: 48 89 e5 mov %rsp,%rbp 400121: 89 7d ec mov %edi,-0x14(%rbp) 400124: 8b 45 ec mov -0x14(%rbp),%eax 400127: 01 c0 add %eax,%eax 400129: 89 45 fc mov %eax,-0x4(%rbp) 40012c: 90 nop 40012d: 5d pop %rbp 40012e: c3 retq 使用nm a.out查看a.out中的符号信息（简略），可以看到export_func_var的地址为0000000000601018 text12[delta@rabbit: c_code ]$ nm a.out0000000000601018 D export_func_var 分析：在链接之后，可以从反汇编中看出main函数的调用func_call_test函数的地方地址已经被修正为func_call_test真正的地址000000000040011d，使用export_func_var变量的地方的地址也修正为export_func_var真正的地址0000000000601018（在nm a.out输出的符号表中）。所以链接器在完成地址空间分配之后就可以确定所有符号的虚拟地址了，链接器就可以根据符号的地址对每个需要重定位的地方进行地址修正。 链接器如何知道哪些地址需要修正呢？有一个重定位表的结构专门保存与重定位相关的信息（比如.text如果有需要重定位的地方，那么就会有一个叫.rela.text的段保存了代码段的重定位信息），使用objdump -r hello.o查看重定位信息如下（简略），可以看到所有需要重定位的地方 text123456[delta@rabbit: c_code ]$ objdump -r hello.oRELOCATION RECORDS FOR [.text]:OFFSET TYPE VALUE000000000000001c R_X86_64_PLT32 func_call_test-0x00000000000000040000000000000022 R_X86_64_PC32 export_func_var-0x0000000000000004000000000000002a R_X86_64_PC32 export_func_var-0x0000000000000004 符号解析：使用nm hello.o可以查看hello.o 中所有的符号信息，如下所示，可以看到export_func_var和func_call_test符号都是未定义状态（U）。所以档链接器扫描完所有的输入目标文件之后，所有的这些未定义的符号都能够在全局符号表中找到，否则就会报符号未定义（undefined reference to）错误。 text12345678910111213141516# 输出hello.o 中所有的符号信息[delta@rabbit: c_code ]$ nm hello.o0000000000000000 D const_string_var U export_func_var U func_call_test0000000000000000 B global_init_var_00000000000000000 D global_init_var_1 U _GLOBAL_OFFSET_TABLE_0000000000000004 C global_uninit_var0000000000000000 T main0000000000000008 b static_global_init_var_00000000000000004 d static_global_init_var_10000000000000004 b static_global_uninit_var000000000000000c b static_local_init_var_0.18090000000000000008 d static_local_init_var_1.18100000000000000010 b static_local_uninit_var.1808 text1234567# 符号未定义错误[delta@rabbit: c_code ]$ ld hello.old: warning: cannot find entry symbol _start; defaulting to 00000000004000e8hello.o: In function `main&#x27;:hello.c:(.text+0x1c): undefined reference to `func_call_test&#x27;hello.c:(.text+0x22): undefined reference to `export_func_var&#x27;hello.c:(.text+0x2a): undefined reference to `export_func_var&#x27; 指令修正方式：（A：保存正在修正位置的值；P：被修正的位置&lt;相对于段开始的偏移量或者虚拟地址&gt;；S：符号的实际地址；L：表示其索引位于重定位条目中的符号的值）以下计算参考 text12345678910111213# hello.o中的重定位信息（简略）[delta@rabbit: c_code ]$ objdump -r hello.oRELOCATION RECORDS FOR [.text]:OFFSET TYPE VALUE000000000000001c R_X86_64_PLT32 func_call_test-0x00000000000000040000000000000022 R_X86_64_PC32 export_func_var-0x0000000000000004000000000000002a R_X86_64_PC32 export_func_var-0x0000000000000004# 解析：# 根据输出符号的重定位类型有R_X86_64_PLT32和R_X86_64_PC32# R_X86_64_PLT32 ： L + A - P（绝对地址修正）# R_X86_64_PC32 ： S + A - P（相对寻址修正）# 其它方式参考：http://www.ucw.cz/~hubicka/papers/abi/node19.html 绝对地址修正：绝对地址修正后的地址为该符号的实际地址，例如调用func_call_test符号的地址被修正成为了绝对地址40011d 相对地址修正：相对地址修正后的地址为符号距离被修正位置的地址差，例如使用export_func_var符号的地址被修正成为了相对地址0x200f0a，mov指令（第一个mov指令）的下一条地址40010e加上这个偏移量0x200f0a就是export_func_var的绝对地址0x601018 COMMON块：根据nm hello.o的输出，如下所示（简略），可以看到global_uninit_var符号的类型为COMMON类型，编译器将未初始化的全局变量作为弱符号处理 text12[delta@rabbit: c_code ]$ nm hello.o0000000000000004 C global_uninit_var 多个符号定义类型情况分析 两个或以上强符号类型不一致：报重定义错误 有一个强符号和多个弱符号：取强符号，若是有弱符号比强符号空间大的情况则编译时会出现warning 两个或者以上弱符号类型不一致：取占用空间最大的弱符号 注：当编译器将一个编译单元编译成目标文件时，如果该编译单元包含弱符号（未初始化或者初始化为0的全局变量是典型），那么该符号所占用的最终空间就是不确定的，所以编译器无法在该阶段为该符号在BSS段分配空间。但是经过链接之后，任何一个符号的大小都确定了，所以它可以在最终输出文件的BSS段为其分配空间。总体来看，未初始化的全局变量是放在BSS段的 3.2.3 静态库链接 定义：静态库可以简单地看做是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件（Linux上常用的C语言静态库libc位于&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.a） 静态链接过程：在链接过程中ld链接器会自动寻找所有需要的符号以及它们所在的目标文件，将这些目标文件从libc.a中“解压”出来，最终将它们链接到一起形成一个可执行文件。使用gcc -v hello.c func.c编译生成可执行文件a.out，可以看到详细的链接过程，产生如下输出（简化版本） text123456789101112131415161718192021222324[delta@delta: code ]$ gcc -v func.c hello.c# 对func.c的预处理和编译过程/usr/lib/gcc/x86_64-linux-gnu/7/cc1 func.c -o /tmp/ccfC6J5E.s# 对func.c产生的.s文件汇编产生二进制文件as -v --64 -o /tmp/ccF4Bar0.o /tmp/ccfC6J5E.s# 对hello.c的预处理和编译过程/usr/lib/gcc/x86_64-linux-gnu/7/cc1 hello.c -o /tmp/ccfC6J5E.s# 对hello.c产生的.s文件汇编产生二进制文件as -v --64 -o /tmp/cc7UmhQl.o /tmp/ccfC6J5E.s# 链接过程/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -dynamic-linker ld-linux-x86-64.so.2 Scrt1.o crti.o crtbeginS.o /tmp/ccF4Bar0.o /tmp/cc7UmhQl.o crtendS.o crtn.o############################################# 实际各个目标文件的位置/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o/tmp/ccF4Bar0.o/tmp/cc7UmhQl.o/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o 可以看到Scrt1.o crti.o crtbeginS.o &#x2F;tmp&#x2F;ccF4Bar0.o &#x2F;tmp&#x2F;cc7UmhQl.o crtendS.o crtn.o被链接入了最终可执行文件 各个文件的解释（来源） 目标文件 说明 crt0.o Older style of the initial runtime code ? Usually not generated anymore with Linux toolchains, but often found in bare metal toolchains. Serves same purpose as crt1.o (see below). crt1.o Newer style of the initial runtime code. Contains the _start symbol which sets up the env with argc&#x2F;argv&#x2F;libc _init&#x2F;libc _fini before jumping to the libc main. glibc calls this file ‘start.S’. crti.o Defines the function prolog; _init in the .init section and _fini in the .fini section. glibc calls this ‘initfini.c’. crtn.o Defines the function epilog. glibc calls this ‘initfini.c’. scrt1.o Used in place of crt1.o when generating PIEs. gcrt1.o Used in place of crt1.o when generating code with profiling information. Compile with -pg. Produces output suitable for the gprof util. Mcrt1.o Like gcrt1.o, but is used with the prof utility. glibc installs this as a dummy file as it’s useless on linux systems. crtbegin.o GCC uses this to find the start of the constructors. crtbeginS.o Used in place of crtbegin.o when generating shared objects&#x2F;PIEs. crtbeginT.o Used in place of crtbegin.o when generating static executables. crtend.o GCC uses this to find the start of the destructors. crtendS.o Used in place of crtend.o when generating shared objects&#x2F;PIEs. 通常链接顺序： text1crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o 链接过程控制：链接过程需要考虑很多内容：使用哪些目标文件？使用哪些库文件？是否保留调试信息、输出文件格式等等。 链接器控制链接过程方法： 使用命令行来给链接器指定参数 将链接器指令存放在目标文件里面，编译器通常会使用这种方式向链接器传递指令。 使用链接控制脚本 3.2.4 BFD库简介 定义：由于现代的硬件和软件平台种类繁多，每个平台都有不同的目标文件格式，导致编译器和链接器很难处理不同平台的目标文件。BFD库（Binary File Descriptor library）希望通过统一的接口来处理不同的目标文件格式。 现代GCC（具体来讲是GNU 汇编器GAS）、链接器、调试器和GDB及binutils的其他工具都是通过BFD库来处理目标文件，而不是直接操作目标文件。 3.3 装载与动态链接3.3.1可执行文件的装载 进程的虚拟地址空间：每个程序运行起来之后，它将拥有自己独立的虚拟地址空间，这个虚拟地址空间的大小由计算机的硬件平台决定，具体来说是CPU的位数决定（32位平台下的虚拟空间为4G&lt;2^32&gt;，通过cat /proc/cpuinfo可以看到虚拟地址的位数，如本机为address sizes : 39 bits physical, 48 bits virtual，虚拟地址位数为48位，则虚拟空间为2^48）。 进程只能使用操作系统分配给进程的地址，否则系统会捕获到这些访问并将其关闭（Window：进程因非法操作需要关闭；Linux：Segment Fault段错误） 装载的方式：程序运行时是有局部性原理的，所以可以将程序最常用的部分驻留在内存中，将不常用的数据存放在磁盘里（动态装入的基本原理） 覆盖装入（几乎被淘汰）：覆盖装入的方法吧挖掘内存潜力的任务交给了程序员，程序员在编写程序时将程序分为若干块，然后编写一个辅助代码来管理这些这些模块何时应该驻留内存，何时应该被替换掉（在多个模块的情况下，程序员需要手工将它们之间的依赖关系组织成树状结构） 页映射：页映射不是一下子将指令和数据一下子装入内存，而是将内存和磁盘中的所有数据和指令按照页（Page）为单位划分，之后所有的装载和操作的单位就是页。 操作系统角度来看可执行文件的加载： 创建一个独立的虚拟地址空间：创建映射函数所需要的对应的数据结构 读取可执行文件头，建立虚拟空间和可执行文件的映射关系：程序在发生页错误时，操作系统从物理空间分配出来一个物理页，然后将“缺页”从磁盘读取到内存中，并设置缺页的虚拟页与物理页的映射关系，很明显，操作系统捕获到缺页错误时，它应该知道当前所需要的页在可执行文件的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系（这种映射关系只是保存在操作系统内部的一个数据结构，Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA））。 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行 注：页错误处理： CPU将控制权交给操作系统 操作系统查询装载过程 第二部建立起来的数据结构，找到空白页所在的VMA，计算出相应页面在可执行文件中的便宜，然后在物理内存中分配一个物理页面，将进程中该虚拟地页与分配的物理页之间建立映射关系 把控制权还给进程 3.3.2 动态链接 为什么需要动态链接：1、静态链接方式对于计算机内存和磁盘空间的浪费非常严重；2、静态链接库对程序的更新部署会带来很多麻烦（如果其中一个依赖进行了更新，那么该程序就要重新链接发布） 动态链接：将链接的过程推迟到了运行的时候再进行，通过动态链接器（第二部分GCC编译过程中最后的链接设置了动态链接器参数dynamic-linker ld-linux-x86-64.so.2 ）完成链接工作，通过延迟绑定等来将动态链接损失的性能尽可能的小。 动态地选择加载各种程序模块 加强程序的兼容性：一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间添加了一个中间层，从而消除程序对不同平台之间依赖的差异性 地址无关代码：共享对象在编译时不能假设自己在进程虚拟空间中的位置。把指令中那些需要修改的部分分离出来与数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中有一个副本，这种方案就是地址无关代码（PIC，Position-Independent Code） 装载时重定位：一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址进行重定位（静态链接时的重定位叫做链接时重定位；动态链接的重定位叫做装载时重定位 ） 模块中国各种类型地址类型引用方式： 模块内部的函数调用、跳转：采用相对地址调用，不需要重定位 模块内部的数据访问，比如模块中定义的全局变量，静态变量：采用相对地址访问，获取当前的PC值，加上偏移量就能访问变量了 模块外部的数据访问，比如其它模块定义的全局变量：ELF的做法是子啊数据段里面建立一个指向这些变量的指针数组，称为全局偏移表（GOT，Global Offset Table）。GOT是放在数据段的，可以在模块装载时被修改，并且每个进程都可以有独立的副本，互相不影响。 模块外部的函数调用、跳转等：通过GOT中的项进行间接跳转 延迟绑定：当函数第一次被用到才进行绑定（符号查找、重定位等），如果没有用到则不绑定。ELF使用PLT（Procedure Linkage Table）的方式来事先延迟绑定（PLT使解析只会在符号未解析时进行一次）。 动态链接的步骤 动态链接器自举：动态链接器不依赖其它任何共享对象；动态链接器本身所需的全局和静态变量的重定位工作由它本身完成 装载共享对象：将可执行文件和链接器本身的符号都合并到一个全局符号表中（图的遍历过程），当一个符号需要加入到全局符号表时，如果相同的符号已经存在，则忽略后加入的符号 重定位与初始化：重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT&#x2F;PLT中的每个需要重定位的地方进行修正。 四、参考文献[0] 程序员的自我修养 ：链接、装载与库 &#x2F; 俞甲子，石凡，潘爱民著.—北京：电子工业出版社 [1] GNU ONLINE DOC - collect2 https://gcc.gnu.org/onlinedocs/gccint/Collect2.html","tags":[{"name":"C++","slug":"C","permalink":"https://www.delta1037.cn/tags/C/"},{"name":"编译","slug":"编译","permalink":"https://www.delta1037.cn/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"Apache配置ssl","date":"2018-07-30T16:00:00.000Z","path":"2018/Deploy/Apache配置ssl/","text":"阿里云申请的ssl证书配置(Apache) 一、下载证书 下载证书 上传到服务器 解压到 &#x2F;etc&#x2F;apache2&#x2F;ssl (不存在则创建) 二、配置Apache 打开SSL模块 $ a2enmod ssl 配置conf 编辑apache2配置文件 $ vim &#x2F;etc&#x2F;apache2&#x2F;apache2.conf apache2配置文件 text123456&lt;Directory /var/www/&gt; Options Indexes FollowSymLinks #把none改为all AllowOverride all Require all granted&lt;/Directory&gt; 编辑port.conf文件 text1$ vim ports.conf port.conf配置 text1234#添加监听443端口&lt;IfModule ssl_module&gt; Listen 443&lt;/IfModule&gt; 配置default-ssl.conf text123456789#添加servernameServerName example.com#修改sslengineSSLEngine on#添加证书文件，按照阿里云给出的示例添加即可#证书的文件位置就是刚刚上传的位置SSLCertificateFile /etc/apache2/ssl/public.pemSSLCertificateKeyFile /etc/apache2/ssl/2146003231320408.keySSLCertificateChainFile /etc/apache2/ssl/chain.pem 三、启用启用刚刚的ssl配置 text1$ a2ensite default-ssl 重启apache服务器 text1$ service apache2 restart OK~","tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.delta1037.cn/tags/SSL/"}]},{"title":"Mysql error 2002","date":"2018-01-30T16:00:00.000Z","path":"2018/Bugsfix/Mysqlerror2002/","text":"Mysql运行报错：ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/var/run/mysqld/mysqld.sock&#39; (2) Mysql error2002配置 DigtalOcean Ubuntu17.04 Mysql5.7* Wordpress 问题 查看网站时显示连接数据库错误 后台登录Mysql显示 ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock’ (2) 解决 内存不足。。。 参考链接-增加交换区 生成交换空间 text1$ sudo fallocate -l 4G /swapfile 查看生成的文件 $ sudo ls -lh &#x2F;swapfile 输出的内容 text1$ -rw-r--r-- 1 root root 4.0G Apr 28 17:19 /swapfile 更改文件的权限 $ sudo sudo chmod 600 &#x2F;swapfile 设置交换空间并使交换空间可用 $ sudo mkswap &#x2F;swapfile$ sudo swapon &#x2F;swapfile 查看设置结果 $ free -m","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.delta1037.cn/tags/MySQL/"}]},{"title":"Permission denied (publickey)","date":"2017-12-05T16:00:00.000Z","path":"2017/Bugsfix/Permissiondenied(publickey)/","text":"SSH连接时出现Permission denied (publickey)错误 Permission denied (publickey)问题描述在用Linux终端使用ssh root@server_ip来连接到远程服务器时，出现Permission denied (publickey).提示 问题原因首先ssh连接服务器是需要一对秘钥的，包括私钥和公钥，私钥（&#x2F;.ssh&#x2F;id_rsa）保存在本地服务器上，而公钥（&#x2F;.ssh&#x2F;id_rsa.pub）保存在远程服务器上（~&#x2F;.ssh&#x2F;authorized_keys文件内）。当使用ssh进行连接时，本地向远程服务器发起连接，服务器会随机生成一个字符串发送给登陆的用户（发起登陆的客户端），用户对该字符串使用私钥加密之后发送给服务器，服务器使用公钥对加密后的字符串解密，如果解密后的字符串与之前发送给客户端的字符串一致，则判断为登陆成功。 综上，Permission denied(publickey)的问题可能如下1、远程服务器没有添加公钥2、远程服务器公钥文件夹权限错误 一、公钥没有添加如果服务器端根本就没有添加公钥是断然不可能通过认证的 Solution客户端已经有秘钥对：通过其它方式登录到远程服务器，查看.&#x2F;ssh&#x2F;authorized_keys文件中是否添加了公钥，若没有可直接将公钥内容拷贝到该文件末尾客户端没有秘钥对：通过ssh-keygen命令生成秘钥对，默认文件夹是&#x2F;.ssh文件夹，将.ssh文件夹内id_rsa.pub的内容拷贝到服务器上的.&#x2F;ssh&#x2F;authorized_keys文件末尾（若服务器上.&#x2F;ssh&#x2F;authorized_keys不存在则也可以使用ssh-keygen来生成文件结构） 二、远程服务器.ssh权限问题远程服务器~&#x2F;.ssh文件夹及其文件权限不对，包括1、authorized_keys文件权限2、.ssh文件夹权限3、.ssh文件夹所有权 Solution通过其它方式登录到远程服务器，如果是阿里云则可以在网页中通过验证之后打开一个终端，然后进行如下操作 更改文件所有权 text12$ chown -R your_user:your_user ~/.ssh//我用root登录，your_user是root 更改文件夹权限 text1$ chmod 700 ～/.ssh 更改authorized_keys文件权限 text1$ chmod 600 ~/.ssh/authorized_keys 参考文献 https://askubuntu.com/questions/311558/ssh-permission-denied-publickey","tags":[{"name":"SSH","slug":"SSH","permalink":"https://www.delta1037.cn/tags/SSH/"}]},{"title":"美化Ubuntu","date":"2017-12-04T16:00:00.000Z","path":"2017/Deploy/美化Ubuntu/","text":"Ubuntu美化（安装macUbuntu主题） 推荐一个装双系统的博客：最近刚装了双系统，重新布置了下Ubuntu的界面，这个博客不错，装双系统可以看一下http://blog.csdn.net/fesdgasdgasdg/article/details/54183577 下载壁纸略。。。（壁纸好看就行了17 张程序员壁纸推荐） 下载主题图标等tip:使用install安装时可能会出现找不到这个安装包的问题，可以使用‘星’符（正则表达式匹配） text1$ sudo apt-get install macbuntu* 来看本地有哪些包可以安装 text1234$ sudo add-apt-repository ppa:noobslab/macbuntu$ sudo apt-get update$ sudo apt-get install macbuntu-os-icons-lts-v7$ sudo apt-get install macbuntu-os-ithemes-lts-v7 安装Plank Docktext1$ sudo apt-get install plank 将plank添加到开机启动-&gt;使用gnome-session(启动器中搜索,打开并将启动命令填入) unity-tweak-tool 安装并打开unity-tweak-tool，修改安装的主题 个人认为可以添加热区使鼠标移到此位置时可以平铺打开的所有界面，及其方便界面之间的切换 另附想要继续美化可以参考第一个链接，可能需要科学上网，鄙人认为只要有plank方便操作就可以了 终端配置简书：五分钟入门Terminator 安装新字体 将新字体拷入&#x2F;usr&#x2F;share&#x2F;fonts中 运行以下命令更新字体缓存 $ sudo fc-cache -f -v 参考链接 http://www.noobslab.com/2016/04/macbuntu-1604-transformation-pack-for.html -http://www.linuxidc.com/Linux/2016-06/131947.htm","tags":[{"name":"美化","slug":"美化","permalink":"https://www.delta1037.cn/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.delta1037.cn/tags/Ubuntu/"}]},{"title":"状态机","date":"2017-09-12T16:00:00.000Z","path":"2017/Algorithm/状态机/","text":"有限状态机介绍 参考文献 有限状态机状态机：表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型 有限状态机的下一个状态和输出，是由输入和当前状态决定的。 分类：接收器和识别器：接收器和识别器（序列检测器）产生一个二元输出，是或者否回答输入是否被机器接受，所有有限状态机的状态是称为接受或者不接受。 在所有处理都被处理，若当前状态是接受状态，输入被接受，否则被拒绝。 开始状态：一个没有起点的箭头 接受（最终）状态：接受状态（最终状态）是机器回报到目前为止，输入的字符串属于它所接收的内容之状态，状态图中通常将其标注为双圆圈 开始状态也可以是接受状态，此情况下自动机会接受空字符串，。如果开始状态不是接受状态，且没有可以连到任何接受状态的箭头，那么此自动机就不会“接受”任何输入 变换器：两种变换器： 1.Moore机，摩尔型有限状态机。 只使用进入动作的有限状态机，也就是输出只依赖于状态 2.Mealy机，米莉型有限状态机。 只使用输入动作的有限状态机，也就是输出依赖于输入和状态","tags":[{"name":"状态机","slug":"状态机","permalink":"https://www.delta1037.cn/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"}]},{"title":"CMake笔记","date":"2017-08-23T16:00:00.000Z","path":"2017/C_C++/CMake笔记/","text":"CMake笔记 CMake它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件 linux平台使用cmake流程 编写 CMake 配置文件 CMakeLists.txt 。 执行命令 cmake CMakeListPath 生成 Makefile 使用 make 命令进行编译。make使用 编写CMakeList.txt文件基本版text123456#CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)#项目信息project (project_name)#指定生成目标add_executable(target_name main.c) text123456789#CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)#项目信息project (project_name)# 使用变量set(SOURCE_FILES file1.c file2.c main.c)set（SOURCE_FILES file1.c file2.c main.c [apend ...]) # 追加方式添加#指定生成目标add_executable(target_name $&#123;SOURCE_FILES&#125;) 添加源文件目录text1234# 添加源文件目录aux_source_directory(srcPath DIR_SRCS)# 指定生成目标add_executable(target_name $&#123;DIR_SRCS&#125;) 添加头文件目录text12# 包含头文件目录include_directories(includeFilePath) 添加子目录子目录中也有有一个CMakeList.txt，子目录下生成一个链接库 text12345# 查找当前目录源文件，将名称aux_source_directory(srcPath DIR_SRCS)# 生成链接库add_library(library_name $&#123;DIR_SRCS&#125;) 在主函数中添加链接库 text123add_excutable(target_name $&#123;SRCS&#125;)# 在指定生成目标之后添加链接库target_link_library(target_name $&#123;library_name&#125;) 添加链接库text12# 所有编译目标都链接的库link_libraries(library_name1 library_name2) text12# 指定动态链接库的搜索路径link_directories(DLLPath) text12# 添加链接库target_link_libraries(target_name $&#123;BOOST_LIBRARIES&#125;) text123# 在指定目录中搜索一个库，并且包含在变量中# 查找并添加动态库(添加一部分)find_library(MY_LIB library_name1 libraryPath) 其它text12# 设置编译参数add_definitions(&quot;-Wall -g&quot;) text12# 添加编译依赖add_dependencies() text1234567# 设置目标属性set_target_properties()# eg：set_target_properties($&#123;project_name&#125; PROPERTIES SOVERSION 0.0.1 PUBLIC_HEADER &quot;include/gtstack.h;include/gttypes.h&quot; ) text1234567# 设置版本号set(VERSION_MAJOR 1) # 最大的版本编号set(VERSION_MINOR 0) # 其次于major的版本号set(VERSION_PATCH 0) # 其次于minor的版本号set(VERSION_TWEAK 0) # 其次于patch的版本号# 版本号：MAJOR.MINOR.PATCH.TWEAK （semver语义化版本号的规则） text12# 输出信息message([SEND_ERROR | STATUS | FATAL_ERROR] “message to display”) 逻辑语法text12LESS,GREATER,EQUAL # 数字比较STRLESS、STRGREATER、STREQUAL # 字符串比较 text1234567if(CONDITION1)...elseif(CONDITION2)...else(CONDITION3)...endif text1234567891011121314151617# 1foreach(loop_var arg1 arg2...) ...endforeach(loop_var)# 2foreach(loop_var RANGE total) ...endforeach(loop_var)# 3foreach(loop_var RANGE start stop [step]) ...endforeach(loop_var)# 4foreach(loop_var IN [LISTS [list1 [...]]] [ITEMS [item1 [...]]]) ...endforeach(loop_var) text123while(CONDITION) ...endwhile(CONDITION) text1234# Logic operationif(FALSE AND (FALSE OR TRUE)) ...endif()","tags":[{"name":"编译","slug":"编译","permalink":"https://www.delta1037.cn/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"Makefile笔记","date":"2017-08-22T16:00:00.000Z","path":"2017/C_C++/Makefile笔记/","text":"Makefile笔记 makefile用来制定编译的规则及其其它更复杂的操作.并且能实现整个工程的自动化编译,提高编译效率 text123# Makefile 格式:target : prerequisites &lt;tab&gt; command 目标：target 文件名 : *.o … (可以是多个，即使是最终目标文件） 操作的名字(伪目标) ： clean … 通过 .PHONY 来声明clean是一个伪目标，而不是一个目标文件,例： .PHONY: clean clean: rm *.o temp 前置条件 prerequisites一组文件名 ： 用空格分开 只要有一个前置条件的文件有过更新，目标就要重新构建 命令 command由一行或者多行的shell命令组成，命令之前必须有tab键 1. 每行命令在一个单独的shell中执行，这些shell之间没有继承关系 2. 多行命令依赖解决： 1、加上.ONESHELL: 2、 用逗号分隔 3、添加换行转义 Makefile 语法注释text123# 这是注释target : prerequisites &lt;tab&gt; command 回声 echoing在执行每一条命令时都会在终端打印这条命令，在命令之前加上@可以关闭 通配符Makefile通配符与bash一致，主要有 1. * : 可以匹配任何字符 2. ？: 匹配任意单个字符 3. […] : 匹配一个单字符范围, 模式匹配对文件名进行类似正则运算的匹配,适应于大量同类型的文件 text1%.o : %.c 变量变量可以用等号赋值，访问时可以使用$(Variable)来访问 所以在使用美元符号的时候可以使用$$来转义 赋值： text1234567891011VARIABLE = value# 在执行时扩展，允许递归扩展。VARIABLE := value# 在定义时扩展。VARIABLE ?= value# 只有在该变量为空时才设置值。VARIABLE += value# 将值追加到变量的尾端。 内置变量 $(CC) ： 指向当前使用的编译器 $(MAKE) ：指向当前使用的Make工具 自动变量 $@ : 指代当前需要生成的目标 $&lt; ： 指代第一个前置条件 $? ： 指代比目标更新的所有前置条件 $^ ： 指代所有前置条件 判断和循环判断 text12345ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endif 循环 text12345LIST = one two threeall: for i in $(LIST); do \\ echo $$i; \\ done 函数格式 text123$(function arguments)# 或者$&#123;function arguments&#125; shell函数text1srcfiles := $(shell echo src/&#123;00..99&#125;.txt) wildcard函数text1srcfiles := $(wildcard src/*.txt) subst 函数text1$(subst from,to,text) patsubst函数text1$(patsubst pattern,replacement,text) 替换后缀名text1min: $(OUTPUT:.js=.min.js) Makefile 执行通过make命令工具来解释makefile中的指令,makefile告诉make需要怎么去编译和链接目标程序,make还能根据当前文件情况确定哪些文件需要重新编译 text1$ make # 自动寻找Makefile text1$ make -f Makefile text1$ make --file=Makefile 附：编译和链接基本流程 源文件–编译–&gt;中间文件 中间文件–链接–&gt;可执行文件 编译链接细节 编译时，编译器需要的是语法，函数与变量的声明是否正确，只要正确就能生成中间文件 链接时，主要是链接函数和全局变量，连接时只管中间目标文件 在中间文件过多时，可以给中间文件打包 注中间文件： 1. Windows：*.obj 2. UNIX ： *.o 文件 打包文件： 1. Window ： 库文件（Library File) .lib 2. Unix ： Archive File， .a 参考文献参考博客","tags":[{"name":"编译","slug":"编译","permalink":"https://www.delta1037.cn/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"Socket笔记","date":"2017-08-21T16:00:00.000Z","path":"2017/CN/Socket笔记/","text":"C Socket学习样例 源代码客户端代码text123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;zconf.h&gt;int main() &#123; //创建套接字 int sock=socket(AF_INET,SOCK_STREAM,0); //向特定的服务器发起请求 struct sockaddr_in serv_addr; memset(&amp;serv_addr,0,sizeof(serv_addr));//用0填充每个字节 serv_addr.sin_family=AF_INET; //使用ipv4 serv_addr.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;); serv_addr.sin_port=htons(1234); //端口 connect(sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); //读取服务器传回的数据 char buffer[40]; read(sock,buffer,sizeof(buffer)-1); printf(&quot;Message from server:%s\\n&quot;,buffer); //关闭套接字 close(sock); return 0;&#125; 服务端代码text123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;zconf.h&gt;int main() &#123; //创建 int serv_sock =socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); //将套接字绑定ip,端口 struct sockaddr_in serv_addr; memset(&amp;serv_addr,0,sizeof(serv_addr)); //填充每个字节用0 serv_addr.sin_family=AF_INET; //使用ipv4 serv_addr.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;); //本机(即服务器)IP地址 serv_addr.sin_port=htons(1234); //使用的端口 bind(serv_sock,(struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); text1234567891011121314151617 //开始监听 listen(serv_sock,20); //接收客户端请求 struct sockaddr_in clnt_addr; socklen_t clnt_addr_size =sizeof(clnt_addr); int clnt_sock=accept(serv_sock,(struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size); //向客户端发送数据 char str[]=&quot;hello world&quot;; write(clnt_sock,str,sizeof(str)); //关闭套接字 close(clnt_sock); close(serv_sock); return 0;&#125;","tags":[{"name":"Socket","slug":"Socket","permalink":"https://www.delta1037.cn/tags/Socket/"}]},{"title":"算法导论笔记","date":"2017-08-07T16:00:00.000Z","path":"2017/Algorithm/算法导论笔记/","text":"算法导论记录：动态规划、贪心算法与图 一、动态规划概念：动态规划（dynamic programming&#x2F;DP）中的programming指的是一种表格法，并非编写计算机程序 动态规划应用于子问题重叠的情况，即不同的子问题有公共的子子问题 动态规划的设计： 1.刻画最优解的结构特征 2.递归地定义最优解的值 3.计算最优解的值（通常采用自底向上的方法） 4.利用计算出的信息构造一个最优解 朴素的递归算法由于反复求解相同的子问题而效率低下；动态规划对每个子问题只求解一次，，并将其保存下来，如果再次需要这个子问题的解，只需要查找保存的结果 动态规划两种等价的实现方法： 1.带备忘的自顶向下法 仍然按自然递归的形式编写过程，但是过程会保存每个子问题的解，当需要某个子问题的解时，会先进行查找是否有这个解，否则会计算这个解，并保存 2.自低向上法（按照逆拓扑排序，反序的拓扑排序）（自底向上表格法） 当求解某个子问题时，它所依赖的那些更小的子问题都已经求解完毕 动态规划的标识： 1.最优子结构 2.子问题重叠 剪切-粘贴：假定子问题的解不是其自身的最优解，那么我们可以剪切掉这些非最优解，将最优解粘贴进去，从而可以得到原问题的一个更优的解，这与原问题是最优解的假设是矛盾的 子问题无关：同一个原问题的一个子问题的解不影响另一个子问题的解 重叠子问题的性质：递归算法反复求解相同的子问题 如果每个子问题必须求解一次，自底向上动态规划算法会比自顶向下备忘算法快，因为自底向上算法没有递归调用的开销；如果子问题中的某些子问题不需要求解，自顶向下备忘算法就比较快 动态规划求解：找到状态转移方程和状态 二、贪心算法概念：贪心算法每一步在当时看起来是最佳的选择，总是做出局部最优的选择 贪心算法并不保证得到最优解，但对于很多问题可以得到最优解 首先考虑用动态规划算法，然后证明一直做贪心的选择可以得到最优解，从而得到一个贪心算法 贪心算法步骤： 确定问题的最优子结构 将最优化问题转化为对其做出一次选择之后，只剩下一个子问题需要求解的形式 证明做出贪心选择之后，原问题总是存在最优解，即贪心选择总是安全的 证明做出贪心选择之后，剩余的子问题满足性质： 最优解和贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构 贪心算法进行选择时可能依赖之前做出的选择，但是不会依赖将来的选择或者是子问题的解 三、图3.1 图的表示 邻接链表：适用于稀疏图 邻接矩阵：适用于稠密图 邻接链表无法迅速判断一条边是否是图中的一条边（邻接矩阵则可以，但是消耗了更多的内存空间），如果使用邻接链表来表示图，一种可能的方法是用额外的数组来表示节点属性 3.2 图的遍历3.2.1 广度优先搜索：广度优先搜索树中两个节点的简单路径就是这两个节点间的最短路径 用队列来实现广度优先搜索 广度优先搜索将每个节点涂上黑色&#x2F;灰色&#x2F;白色，遇到白色节点为发现，对于灰色节点，该节点周围肯能存在尚未发现的节点，对于黑色节点，该节点周围所有的节点都已经被发现 队列里面的距离差值最大为一 对图进行广度优先搜索的过程中将创建一棵广度优先搜索树 3.2.2 深度优先搜索：深度优先搜索的前驱子图形成一个由多棵深度优先树构成的深度优先森林 若深度优先搜索中一个节点周围没有节点，则会回退到上一个节点，然后发现该节点周围的节点 发现时间和完成时间具有括号化结构（即嵌套）： 深度优先搜索在每个节点上面盖一个时间戳，一个是发现时间，第二个是搜索完成时间，对两个节点的时间戳，若重叠则必定是包含关系 边的分类： 树边&#x2F;后向边&#x2F;前向边&#x2F;横向边 对无向图，从来不会出现前向边和横向边 拓扑排序： 拓扑排序是图中节点的一种线性排序，其次若图中有环路则无法排出一个线性次序 与深度优先搜索有关 强连通分量：深度优先搜索的应用：将有向图分解为强连通分量 将图分解成强连通分量之后，这些算法将运行在每个连通分量上，然后根据连通分量之间的结构将各个结果组合起来，从而得到最终结果 强连通分量就是将环收缩，形成一个有向无环图 寻找强连通分量，图和改图的转置的强连通分量完全相同 分量图是一个有向无环图 单源最短路径单源最短路径的子路径也是最短路径 单源最短路径包含着其它的最短路径（最优子结构） 求解最短路径的图中不能包含权值为负值的环路 事实上，最短路径也不能包含权重为正值的环路（无效环路），只要删去该环路，就可以得到一个更短的路径 松弛： 维持节点的最短路径估计属性 过程：首先测试是否可以对两个节点的最短路径进行改善，测试方法是：将一个节点到中间节点加上中间节点到另一个节点的值与当前值进行比较，如果更小则更新节点的该属性值 Dijkstra算法和用于有向无环图的最短路径算法对每条边仅仅松弛一次，Bellman——Ford算法对每条边松弛节点数减一次 Bellman——Ford算法： Bellman——Ford算法通过对边进行松弛操作，来渐进的降低从源节点到每个节点的最短路径的估计值， 先对图进行拓扑排序。。降低时间复杂度 Dijkstra算法：（贪心算法） Dijkstra算法要求所有的边的权重是非负 Dijkstra算法在运行过程中维持的关键信息是一组节点集合，从源节点到该集合中的每个节点之间的最短路径都已经找到，使用一个最小优先队列来保存节点集合 四、树4.1 最小生成树最小生成树问题： 对于带有权重的图，找到一个无环子集，既能够将所有的节点连接起来，又使其具有最小的权重 两种最小生成树算法：（贪心算法） kruskal算法 prim算法 kruskal算法： 集合a是一个森林，每次加入到集合a中的安全边永远是权重最小的连接两个不同分量的边 prim算法： 集合a是一棵树，每次加入a中的安全边是连接a与a之外的某个节点的边权重最小的 使用一个最小优先队列，算法结束时，最小优先队列为空 4.2二叉树二叉搜索树上所花费的时间与这棵树的高度成正比 区分树的高度和深度 二叉搜索树： 左子树中的关键字的值小于根节点中关键字的值，右子树中关键字的值大于根节点中关键字的值 二叉搜索树的遍历： 先序遍历 中序遍历 后序遍历 其中序是指根节点的位置 二叉搜索树的查找 迭代比递归更加高效 比较关键字的值，大于向右，小于向左 插入和删除： 插入类似于查找，即查找到一个空的合适的位置，将该节点插入 删除则分为三种情况 将删除的节点没有孩子节点，直接删除 将删除的节点只有一个孩子节点，将这个孩子提升到将删除节点的位置，并修改将删除节点的父节点， 将删除的节点有两个孩子节点，查找将要删除节点的后继，并让该后继占据将要删除的节点的位置，让将删除节点的右子树部分成为那个后继的新的右子树，并且将删除节点的左子树成为那个后继的新的左子树 红黑树： 红黑树保证没有一条路径会比其它路径长出两倍，是近似平衡的，平衡二叉树是绝对平衡的 红黑树性质： 每个节点是红色的或者是黑色的 根节点是黑色的 每个叶节点是黑色的 如果一个节点是红色的，那么它的两个子节点是黑色的 对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含数目相同的黑色节点数，成为黑高 红黑树的旋转： 左旋和右旋 左旋是靠左边的节点下滑，夺取右子树的左子树作为自己的右子树，同时自己从新成为右子树的左子树 右旋是靠右边的节点下滑，夺取左子树的右子树作为自己的左子树，同事自己从新成为左子树的右子树 红黑树的插入： 红黑树的性质2或者4被破坏 插入的节点首先着色为红色 为保持红黑树的性质，调用辅助程序对红黑树的节点重新着色并进行旋转 红黑树的删除： 删除节点之后，调用辅助程序通过改变颜色和执行旋转来恢复红黑树性质 如果删除的节点是红色，则不需要对树进行恢复","tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://www.delta1037.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"Hexo+Github搭建博客","date":"2017-08-07T16:00:00.000Z","path":"2017/Deploy/Hexo+Github搭建博客/","text":"花费了将近十个小时,查阅了上百篇资料,终于搭建好了自己的第一个博客,就以这第一篇博客纪念我走过的坑 预览网站 系统系统类型Ubuntu 17.04 环境Git 和Node.js安装Git使用以下命令 text1$ sudo apt-get install git 检查版本 text1$ git --version 安装Node.js由于用apt-get的方式,后续步骤中会出现错误,建议使用源码安装,安装前应该先安装好Python和gcc等编译器安装网址:源代码安装网址 下载后使用cd命令进入文件夹,分别执行以下命令: text123$ ./configure$ make$ make install 检查版本 text1$ node -v 安装npm执行命令 text1$ sudo apt-get install npm 安装hexo和注册github并创建托管博客代码的仓库安装hexohexo官网上给出的命令是 text1$ npm install hexo-cli -g 该命令本人验证会出错,可使用以下命令安装 text1$ sudo npm install --unsafe-perm --verbose -g hexo hexo init blog 不能初始化的问题: (taobao源貌似不能使用) 用nrm ls命令,列出所有的可用的源,用nrm use cnpm命令,选择cnpm 若还不能使用…… 用npm test命令测试所有原,找一个可用的源名称,使用npm use + 源名称命令更换就可以 博客初始化根目录 text1$ hexo init #初始化博客所在根目录 一些常用命令 text1234$ cd blog #进入所在目录$ npm install // ** 注意，一定要加这个命令！！！！否则生成的public\\index.html文件可能各种空白$ hexo g #或者hexo generate //生成静态页面$ hexo s #或者hexo server 本地查看 打开http://localhost:4000/ 已经可以看到一篇内置的blog了 text123$ hexo d #或者hexo deploy //部署博客到远程$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面 本地查看hexo s 命令可能出现错误log 使用如下命令可以解决 text1$ hexo s -s 更换主题(eg:yilia)text12$ cd /blog/themes #切换到主题目录$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #克隆主题到本地,可以在github上搜索主题,替换相应链接就可以了 修改Hexo目录下的 _config.yml 配置文件中的theme属性，将其设置为yilia(根据主题名称设定) 注册githubGithub官网 创建账户登录之后,新建一个代码仓库,注意仓库名称为 [账户名.github.io] 格式,注意的个人主页的网站内容是在master分支下的,可以通过http://username.github.io 来访问你的个人主页 使用hexo deploy部署如将代码部署到github，在配置文件 _config.xml中作如下修改： text1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 使用如下命令,即可完成部署,即可在github上创建的仓库里看到代码 text1$ hexo d 该处需要安装一个拓展 text1$ npm install hexo-deployer-git --save 使用ssh(不需要输用户名密码,只需要输入设置的密码短语即可)参考链接 创建pubic key text1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; #该处是邮箱,大写C 在 &#x2F;home&#x2F;you&#x2F;.ssh&#x2F;id_rsa目录下(如果在选择目录时直接enter就是这个目录)会生成两个文件，id_rsa.pub和id_rsa, 然后登陆github，在SSH设置页面添加上刚才的public key文件也就是id_rsa.pub的内容即可 当Enter passphrase时,记住该语句,使用ssh时需要输这个短语,即 text12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 绑定域名text12345$ cd source/$ touch CNAME$ vim CNAME # 输入你的域名$ git add CNAME$ git commit -m &quot;add CNAME&quot; 在注册商那里添加解析就可以了 参考链接: - 令狐葱@前端笔记","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.delta1037.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"LAMP+WordPress搭建网站","date":"2017-08-07T16:00:00.000Z","path":"2017/Deploy/LAMP+WordPress搭建网站/","text":"LAMP+WordPress搭建博客网站 搭建LAMP（Linux, Apache, MySQL, PHP）环境安装Apachetext12sudo apt-get updatesudo apt-get install apache2 安装完成之后在浏览器页面输入http://your_server_IP_address 可以看到Apache的配置页面 安装数据库MySQLtext1sudo apt-get install mysql-server php7.0-mysql 首先，我们要让MySQL创建它的存储信息的数据库目录结构，输入以下命令 text1sudo mysql_install_db 然后运行一个简单的安全脚本，它会移除一些危险的默认的配置 text1sudo mysql_secure_installation 它将会要求输入root密码，然后问是否想要修改密码，如果对现在的密码满意，就输入n或者no；对于剩下的问题，只需要enter键接受默认的配置就可以，这将会移除一些样例用户和数据库，使远程root登录不可用，并且加载这些新的规则来做出我们所做的更新 安装PHP安装 text1sudo apt-get install php7.0 libapache2-mod-php7.0 php7.0-mcrypt 更改dir.conf文件： text1sudo nano /etc/apache2/mods-enabled/dir.conf 更改前： text123&lt;IfModule mod_dir.c&gt; DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm&lt;/IfModule&gt; 更改后：&lt;其中只是移动了ingdex.php的位置&gt; text123&lt;IfModule mod_dir.c&gt; DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm&lt;/IfModule&gt; 重启Apache： text1sudo service apache2 restart 测试PHP模块：创建新的文件 text1sudo nano /var/www/html/info.php 输入文件内容 text123&lt;?phpphpinfo();?&gt; 打开http://your_server_IP_address&#x2F;info.php 查看测试结果 注意删除这个文件 text1sudo rm /var/www/html/info.php 安装Wordpress创建数据库用户登录数据库 text1mysql -u root -p 创建新的用户，用户名假设为Wordpress text1CREATE DATABASE wordpress; 创建一个数据库用户 text1CREATE USER wordpressuser@localhost IDENTIFIED BY &#x27;password&#x27;; 给这个用户新数据库的使用权 text1GRANT ALL PRIVILEGES ON wordpress.* TO wordpressuser@localhost; 使操作生效并退出 text12FLUSH PRIVILEGES;exit 下载WordPress并配置切换到～目录并获得WordPress的最新版本 text12cd ~wget http://wordpress.org/latest.tar.gz 解压该文件 text1tar xzvf latest.tar.gz 下载一些安装包 text12sudo apt-get updatesudo apt-get install php7.0-gd libssh2-php 复制一个配置文件的副本 text1cp wp-config-sample.php wp-config.php 获得安全秘钥 text1curl -s https://api.wordpress.org/secret-key/1.1/salt/ 会得到类似的输出&lt;警告：不要拷贝下面的！！&gt; text12345678define(&#x27;AUTH_KEY&#x27;, &#x27;1jl/vqfs&lt;XhdXoAPz9 DO NOT COPY THESE VALUES c_j&#123;iwqD^&lt;+c9.k&lt;J@4H&#x27;);define(&#x27;SECURE_AUTH_KEY&#x27;, &#x27;E2N-h2]Dcvp+aS/p7X DO NOT COPY THESE VALUES &#123;Ka(f;rv?Pxf&#125;)CgLi-3&#x27;);define(&#x27;LOGGED_IN_KEY&#x27;, &#x27;W(50,&#123;W^,OPB%PB&lt;JF DO NOT COPY THESE VALUES 2;y&amp;,2m%3]R6DUth[;88&#x27;);define(&#x27;NONCE_KEY&#x27;, &#x27;ll,4UC)7ua+8&lt;!4VM+ DO NOT COPY THESE VALUES #`DXF+[$atzM7 o^-C7g&#x27;);define(&#x27;AUTH_SALT&#x27;, &#x27;koMrurzOA+|L_lG&#125;kf DO NOT COPY THESE VALUES 07VC*Lj*lD&amp;?3w!BT#-&#x27;);define(&#x27;SECURE_AUTH_SALT&#x27;, &#x27;p32*p,]z%LZ+7pAu:VY DO NOT COPY THESE VALUES C-?y+K0DK_+F|0h&#123;!_xY&#x27;);4define(&#x27;LOGGED_IN_SALT&#x27;, &#x27;i^/G2W7!-H2OQ+t$3 DO NOT COPY THESE VALUES t6**bRVFSD[Hi])-qS`|&#x27;);define(&#x27;NONCE_SALT&#x27;, &#x27;Q6]U:K?j4L%Z]&#125;h^q7 DO NOT COPY THESE VALUES 1%^qUswWgn+6&amp;xqHN&amp;%&#x27;); 打开配置文件 text1nano wp-config.php 将秘钥替换配置中类似的位置 找到关于 DB_NAME, DB_USER, 和 DB_PASSWORD 的设置，并填写相应的刚刚配置数据库的信息 text123456789// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&#x27;DB_NAME&#x27;, &#x27;wordpress&#x27;);/** MySQL database username */define(&#x27;DB_USER&#x27;, &#x27;wordpressuser&#x27;);/** MySQL database password */define(&#x27;DB_PASSWORD&#x27;, &#x27;password&#x27;); 拷贝文件到根目录 text1sudo rsync -avP ~/wordpress/ /var/www/html/ 更改文件的权限 text1sudo chown -R demo:www-data * 创建上传目录并赋相应的权限 text12mkdir /var/www/html/wp-content/uploadssudo chown -R :www-data /var/www/html/wp-content/uploads 完成安装并查看网站并完成最后的配置 text1http://server_domain_name_or_IP 允许Apache使用固定连接功能编辑000-default.conf text1sudo nano /etc/apache2/sites-available/000-default.conf 做如下更改 text12345678&lt;VirtualHost *:80&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/html ServerName server_domain_name_or_IP &lt;Directory /var/www/html/&gt; AllowOverride All &lt;/Directory&gt; . . . 重新启动部件 text12//sudo a2enmod rewritesudo service apache2 restart 创建.htaccess文件 text1touch /var/www/html/.htaccess 赋相应权限 text1sudo chown :www-data /var/www/html/.htaccess 如果想要Wordpress自动更新这个文件 text1chmod 664 /var/www/html/.htaccess If you want to update this file manually for the sake of a small security gain, you can allow the web server only read privileges by typing: text1chmod 644 /var/www/html/.htaccess 网站在不同vps之间的迁移VPS1上数据打包（备份）文件数据打包text12cd /home/wwwroot/tar zcvf xxx.tar.gz 网站目录（如/home/wwwroot/vmvps.com） MySQL数据导出text1mysqldump -u用户名 -p密码 数据库名 &gt; xxx.sql VPS2上数据转移（恢复）文件数据恢复（wget获取远程文件）text123cd /home/wwwroot/wget http://www.xxx.com/xxx.tar.gz（从VPS1上获取文件）tar zxvf xxx.tar.gz MySQL数据导入 请先在phpmyadmin新建相应数据库和用户（与原数据库、用户同名）&lt;若不同名则有可能出现数据库连接错误&gt; text12wget http://www.xxx.com/xxx.sqlmysql -u你新建的用户名 -p用户名密码 你刚才新建的数据库名 &lt; xxx.sql 参考链接How To Install Wordpress on Ubuntu 14.04 How To Install Linux, Apache, MySQL, PHP (LAMP) stack on Ubuntu 14.04 VPS之间网站数据的备份与恢复（网站迁移教程）【微魔部落原创】","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.delta1037.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]