<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delta1037</title>
  
  <subtitle>技术是纯净的</subtitle>
  <link href="https://www.delta1037.cn/atom.xml" rel="self"/>
  
  <link href="https://www.delta1037.cn/"/>
  <updated>2025-09-07T10:48:04.936Z</updated>
  <id>https://www.delta1037.cn/</id>
  
  <author>
    <name>delta1037</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matplotlib图像结构</title>
    <link href="https://www.delta1037.cn/2023/Skill/Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84/"/>
    <id>https://www.delta1037.cn/2023/Skill/Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84/</id>
    <published>2023-07-28T16:00:00.000Z</published>
    <updated>2025-09-07T10:48:04.936Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要梳理Matplotlib中的元素；如何使用Subplot和Axes控制子图，以及调整子图之间的间距；最后简要说明了Matplotlib的数据输入和图像输出的控制</p><span id="more"></span><h1 id="一、元素"><a href="#一、元素" class="headerlink" title="一、元素"></a><strong>一、元素</strong></h1><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_54ea9d5031394848b86c7a76dfa890f7.png" alt="54ea9d5031394848b86c7a76dfa890f7"></p><p><strong>标题 - Title</strong>：图像的名字</p><p><strong>图例 - Legend</strong>：展示每个数据图像对应的名称</p><p><strong>边界 - spines</strong>：图四周的框的边界（注意 tick 刻度和所在的线是分离的）</p><p><strong>标记 - Marker</strong>：图线的标记类型</p><p><strong>标签 - Label</strong>：一些细节的标识</p><ul><li>X 轴标签</li><li>Y 轴标签</li><li>主刻度标签</li><li>副刻度标签</li></ul><p><strong>刻度 - tick</strong>：标识对应位置的数值</p><ul><li>主刻度</li><li>副刻度</li></ul><p><strong>字体 - font</strong>：文字的类型</p><p><strong>颜色 - color</strong>：线条、文字</p><h1 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a><strong>二、结构</strong></h1><p>Matplotlib 创建的主体称为 Figure，再 Figure 中可以创建子图，子图中就是一些标签元素和数值元素了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 新建画板</span></span><br><span class="line"> fig = plt.figure()</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 新建画布</span></span><br><span class="line"> ax = fig.add_subplot()</span><br><span class="line"> <span class="comment"># or</span></span><br><span class="line"> ax = fig.add_axes()</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 接下来就可以在ax上绘制图像，或者设置标签等</span></span><br><span class="line"> <span class="comment"># 画板与画布：画板是固定的，画布则可以有多个并且位置可以调整</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 可以对fig做画板的控制（设置画板标题、保存画板图像等）</span></span><br></pre></td></tr></table></figure><blockquote><p>在子图控制中可以通过 plt 添加子图，也可以通过 fig 来添加子图，这两者的区别是 plt 底层还是用的 fig 对象，在源码中有一个 gcf() 函数，会获取当前活跃的 figure（Get the current figure.）</p></blockquote><h2 id="2-1-子图控制"><a href="#2-1-子图控制" class="headerlink" title="2.1 子图控制"></a><strong>2.1 子图控制</strong></h2><p>对于子图的控制，Matplotlib 中有 Axes 和 Subplot 两种控制方式。</p><h3 id="Subplot"><a href="#Subplot" class="headerlink" title="Subplot"></a><strong>Subplot</strong></h3><h3 id="标准网格布局"><a href="#标准网格布局" class="headerlink" title="标准网格布局"></a><strong>标准网格布局</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">1000</span>) <span class="comment"># 新建画板</span></span><br><span class="line"> ax = fig.add_subplot(<span class="number">2</span>, <span class="number">3</span>, idx)              <span class="comment"># 新建画布</span></span><br></pre></td></tr></table></figure><p><code>add_subplot</code> 方法里面传入三个数字，前两个数字代表要生成几行几列的子图矩阵，第三个数字代表选中的子图位置。因此 <code>add_subplot</code> 适合排布规范的多子图形式。</p><p>另外也可以通过 <code>plt</code> 直接设置网格，并获取到网格轴域 <code>ax</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 两行一列的图</span></span><br><span class="line"> <span class="comment">#（但是这种方式已经准备弃用了</span></span><br><span class="line"> <span class="comment">#  Support for FigureCanvases without a required_interactive_framework attribute was deprecated</span></span><br><span class="line"> <span class="comment">#  in Matplotlib 3.6 and will be removed two minor releases later.）</span></span><br><span class="line"> fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"> ax1.plot(X, Y1, color=<span class="string">&quot;C1&quot;</span>)</span><br><span class="line"> ax2.plot(X, Y2, color=<span class="string">&quot;C0&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="自定义网格布局"><a href="#自定义网格布局" class="headerlink" title="自定义网格布局"></a><strong>自定义网格布局</strong></h3><p>使用 <code>add_gridspec</code> 做更复杂的网格布局（占用多个网格作为一个图）</p><p><strong>设置网格的方式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> fig3 = plt.figure(constrained_layout=<span class="literal">True</span>)</span><br><span class="line"> gs = fig3.add_gridspec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"> f3_ax1 = fig3.add_subplot(gs[<span class="number">0</span>, :])</span><br><span class="line"> f3_ax1.set_title(<span class="string">&#x27;gs[0, :]&#x27;</span>)</span><br><span class="line"> f3_ax2 = fig3.add_subplot(gs[<span class="number">1</span>, :-<span class="number">1</span>])</span><br><span class="line"> f3_ax2.set_title(<span class="string">&#x27;gs[1, :-1]&#x27;</span>)</span><br><span class="line"> f3_ax3 = fig3.add_subplot(gs[<span class="number">1</span>:, -<span class="number">1</span>])</span><br><span class="line"> f3_ax3.set_title(<span class="string">&#x27;gs[1:, -1]&#x27;</span>)</span><br><span class="line"> f3_ax4 = fig3.add_subplot(gs[-<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"> f3_ax4.set_title(<span class="string">&#x27;gs[-1, 0]&#x27;</span>)</span><br><span class="line"> f3_ax5 = fig3.add_subplot(gs[-<span class="number">1</span>, -<span class="number">2</span>])</span><br><span class="line"> f3_ax5.set_title(<span class="string">&#x27;gs[-1, -2]&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_b4956923db74477abbfa76eaa07043ed.png" alt="b4956923db74477abbfa76eaa07043ed"></p><p><strong>设置比例的方式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> fig5 = plt.figure(constrained_layout=<span class="literal">True</span>)</span><br><span class="line"> widths = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1.5</span>]</span><br><span class="line"> heights = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"> spec5 = fig5.add_gridspec(</span><br><span class="line">     ncols=<span class="number">3</span>,</span><br><span class="line">     nrows=<span class="number">3</span>,</span><br><span class="line">     width_ratios=widths,</span><br><span class="line">     height_ratios=heights)</span><br><span class="line"> <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">     <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">         ax = fig5.add_subplot(spec5[row, col])</span><br></pre></td></tr></table></figure><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_edc553a4b3114cd096cad33d5422383d.png" alt="edc553a4b3114cd096cad33d5422383d"></p><h3 id="Axes"><a href="#Axes" class="headerlink" title="Axes"></a><strong>Axes</strong></h3><h3 id="画板上新增轴子图"><a href="#画板上新增轴子图" class="headerlink" title="画板上新增轴子图"></a><strong>画板上新增轴子图</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> fig = plt.figure()                     <span class="comment"># 新建画板</span></span><br><span class="line"> ax1 = fig.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])  <span class="comment"># 新建画布</span></span><br><span class="line"> ax2 = fig.add_axes([<span class="number">0.2</span>,<span class="number">0.5</span>,<span class="number">0.4</span>,<span class="number">0.3</span>])</span><br></pre></td></tr></table></figure><p><code>add_axes</code> 方法传入一个位置列表，列表中有四个值，格式如 <code>[left, bottom, width, height]</code>。其中 left 和 bottom 分别表示距离左侧和下边占整张图的比例（0-1 的取值范围），width 和 height 分别表示宽度和高度占整张图的比例（0-1 的取值范围），也就是起始位置是从左下角开始计算的（坐标系原点）。因此 <code>add_axes</code> 方法可以在图上的任意一个位置建立坐标轴并绘制曲线。</p><h3 id="子图中新增轴子图"><a href="#子图中新增轴子图" class="headerlink" title="子图中新增轴子图"></a><strong>子图中新增轴子图</strong></h3><blockquote><p>可以用来放大某一个指定区域</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Implementation of matplotlib function</span></span><br><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"> fig, ax = plt.subplots()</span><br><span class="line"> ax.plot(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"> axin1 = ax.inset_axes(</span><br><span class="line">         <span class="comment"># 相对坐标，由 transform 决定</span></span><br><span class="line">         [<span class="number">0.8</span>, <span class="number">0.1</span>, <span class="number">0.15</span>, <span class="number">0.15</span>])</span><br><span class="line">         <span class="comment"># transform 默认是 transAxes</span></span><br><span class="line"> axin2 = ax.inset_axes(</span><br><span class="line">         <span class="comment"># 数据坐标，由 transform 决定</span></span><br><span class="line">         [<span class="number">5</span>, <span class="number">7</span>, <span class="number">2.3</span>, <span class="number">2.3</span>],</span><br><span class="line">         transform = ax.transData)</span><br><span class="line"> </span><br><span class="line"> ax.set_title(</span><br><span class="line">     <span class="string">&#x27;matplotlib.axes.Axes.inset_axes() Example&#x27;</span>,</span><br><span class="line">     fontsize = <span class="number">14</span>,</span><br><span class="line">     fontweight =<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"> fig.show() <span class="comment"># 会闪退，但是可以savefig</span></span><br><span class="line"> <span class="comment"># or</span></span><br><span class="line"> plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_4778e0ef4913417a90039d5d0d4bd08d.png" alt="4778e0ef4913417a90039d5d0d4bd08d"></p><h3 id="双轴图"><a href="#双轴图" class="headerlink" title="双轴图"></a><strong>双轴图</strong></h3><blockquote><p>可以在同一块区域使用不同的坐标，场景为多种曲线或者图形需要配置对应的坐标</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 共用x轴，双纵轴图</span></span><br><span class="line"> new_ax = ax.twinx()</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 公用y轴，双横轴图</span></span><br><span class="line"> new_ax = ax.twiny()</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 新建两个轴(新画布是右边和上边的轴)</span></span><br><span class="line"> new_ax = ax..twinx().twiny()</span><br></pre></td></tr></table></figure><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_141b56d20e024b23b9f0f900a9a15cf6.png" alt="141b56d20e024b23b9f0f900a9a15cf6"></p><h3 id="附加轴子图（colorbar）"><a href="#附加轴子图（colorbar）" class="headerlink" title="附加轴子图（colorbar）"></a><strong>附加轴子图（colorbar）</strong></h3><p><code>make_axes_locatable</code> 是 Matplotlib 库中的一个函数，它用于创建一个新的 Axes 对象，并将其放置在主图 Axes 对象旁边的位置，以容纳 colorbar。这个函数通常用于在 Matplotlib 绘图中创建 colorbar。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> mpl_toolkits.axes_grid1 <span class="keyword">import</span> make_axes_locatable</span><br><span class="line"> <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> fig, ax = plt.subplots()</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># ... 画图 ...</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 创建附加轴位置、大小、间距</span></span><br><span class="line"> divider = make_axes_locatable(ax)</span><br><span class="line"> cax = divider.append_axes(<span class="string">&#x27;right&#x27;</span>, size=<span class="string">&#x27;5%&#x27;</span>, pad=<span class="number">0.05</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 在新的 Axes 对象上创建 colorbar</span></span><br><span class="line"> plt.colorbar(cax=cax)</span><br></pre></td></tr></table></figure><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_44be687a323747fda9e9c6fab2139f7b.png" alt="44be687a323747fda9e9c6fab2139f7b"></p><h3 id="Axes-和-Subplot-总结"><a href="#Axes-和-Subplot-总结" class="headerlink" title="Axes 和 Subplot 总结"></a><strong>Axes 和 Subplot 总结</strong></h3><ul><li>两种对象确实是“你中有我，我中有你”的关系，生成子图（subplot）的时候，必然带着所谓的一套轴域（Axes）。而用轴域（Axes）方法，客观上就是生成了一个可以画图的子图。</li><li><code>add_subplot</code> 方法在生成子图过程，简单明了；而用 <code>add_axes</code> 方法，则生成子图的灵活性更强，完全可以实现 <code>add_subplot</code> 方法的功能，可以控制子图显示位置，甚至实现相互重叠的效果。</li></ul><p>通过新增子图获取到轴域就可以对其新增数据，增加图像的细节了。</p><h2 id="2-2-间距调整"><a href="#2-2-间距调整" class="headerlink" title="2.2 间距调整"></a><strong>2.2 间距调整</strong></h2><p>给子图添加标题和坐标轴标签后，子图可能会发生重叠，可以通过如下接口来调整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 调整图位置和间距</span></span><br><span class="line"> plt.subplots_adjust(</span><br><span class="line">         left=<span class="literal">None</span>,</span><br><span class="line">         bottom=<span class="literal">None</span>,</span><br><span class="line">         right=<span class="literal">None</span>,</span><br><span class="line">         top=<span class="literal">None</span>,</span><br><span class="line">         wspace=<span class="literal">None</span>,</span><br><span class="line">         hspace=<span class="literal">None</span>)</span><br><span class="line"> <span class="comment"># 整张图位置</span></span><br><span class="line"> <span class="comment"># left ： 子图在画板上的左位置（position），默认0.125</span></span><br><span class="line"> <span class="comment"># right ： 子图在画板上的右位置（position），默认0.9</span></span><br><span class="line"> <span class="comment"># bottom ： 子图在画板上的下位置（position），默认0.1</span></span><br><span class="line"> <span class="comment"># top： 子图在画板上的上位置（position），默认0.9</span></span><br><span class="line"> <span class="comment"># 间距</span></span><br><span class="line"> <span class="comment"># wspace：子图之间的横向间距（padding），默认0.2</span></span><br><span class="line"> <span class="comment"># hspace：子图之间的纵向间距（padding），默认0.2</span></span><br></pre></td></tr></table></figure><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/Skill_Matplotlib%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%84_ffeb5c5223af477e9e463e2d78692005.png" alt="ffeb5c5223af477e9e463e2d78692005"></p><h1 id="三、数据"><a href="#三、数据" class="headerlink" title="三、数据"></a><strong>三、数据</strong></h1><h2 id="3-1-输入"><a href="#3-1-输入" class="headerlink" title="3.1 输入"></a><strong>3.1 输入</strong></h2><p>Matplotlib 只能接收 <code>np.array</code> 格式或者 <code>np.ma.masked_array</code> 格式的数据。不接受类似数组的数据例如 <code>pandas</code> 和 <code>np.matrix</code> 类型的，最好将其转换成 <code>np.array</code> 类型。</p><p>pandas 类型转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> a = pandas.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">5</span>), columns = <span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"> a_asarray = a.values</span><br></pre></td></tr></table></figure><p><code>np.matrix</code> 类型转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> b = np.matrix([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"> b_asarray = np.asarray(b)</span><br></pre></td></tr></table></figure><h2 id="3-2-输出"><a href="#3-2-输出" class="headerlink" title="3.2 输出"></a><strong>3.2 输出</strong></h2><p>保存图像到本地文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> plt.savefig(<span class="string">&#x27;pic_name.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://www.zhihu.com/question/51745620">python matplotlib 中 axes 与 axis 的区别是什么?</a></p><p>‍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简要梳理Matplotlib中的元素；如何使用Subplot和Axes控制子图，以及调整子图之间的间距；最后简要说明了Matplotlib的数据输入和图像输出的控制&lt;/p&gt;</summary>
    
    
    
    <category term="绘图" scheme="https://www.delta1037.cn/categories/%E7%BB%98%E5%9B%BE/"/>
    
    
    <category term="Python" scheme="https://www.delta1037.cn/tags/Python/"/>
    
    <category term="绘图工具" scheme="https://www.delta1037.cn/tags/%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于NS3的无线链路物理层仿真实验</title>
    <link href="https://www.delta1037.cn/2019/School/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/"/>
    <id>https://www.delta1037.cn/2019/School/%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C/</id>
    <published>2019-02-10T16:00:00.000Z</published>
    <updated>2025-09-07T10:48:04.792Z</updated>
    
    <content type="html"><![CDATA[<p>基于NS3的无线链路物理层仿真实验</p><span id="more"></span><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h2><ol><li>掌握NS3的基本仿真方法</li><li>熟悉NS3的无线链路模型</li><li>改进NS3的无线链路模型</li></ol><h2 id="二、实验背景"><a href="#二、实验背景" class="headerlink" title="二、实验背景"></a><strong>二、实验背景</strong></h2><p>在原有的NS3的无线模型中,很难去控制链路的速率，延迟和错误等属性，例如在原有的模型中，错误率是不随距离变化的，即只要在可以传输的范围之内，错误率都是一样的，但是在实际中，随着距离的增加，错误率应该逐渐上升，而不是保持不变，因此我们在现有的模型中做出了一些改进，引入随着距离增加错误率逐渐增加的错误模型，并且引入丢头队列和丢尾队列来模拟不同队列的场景下传输速率的变化，同时加入定向网络的模型，实现定向传输的功能并且支持固定争用模型，即在冲突范围内，随着用户数量的增加，收包率逐渐下降。</p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a><strong>三、实验原理</strong></h2><h3 id="1-错误模型"><a href="#1-错误模型" class="headerlink" title="1.错误模型"></a><strong>1.错误模型</strong></h3><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E4%B8%80-%E8%8A%82%E7%82%B9%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="图一:节点分布图"></p><p>上图是基于NS3的错误模型节点分布图，如图所示，节点0分布在半径为100的圆的中心，其余100个节点以节点0为中心半径为100的圆内随机分布，同时节点0向周围节点发送数据，传输距离为100.  在NS3原有的错误模型中，节点0向各个节点发送数据的丢包率是一样的，但是实际场景中随着距离的增加，丢包率会逐渐上升，经过研究和调查，我们所构建的丢包率曲线如下图</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E4%BA%8C-%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png" alt="图二:丢包率曲线"></p><h3 id="2-队列模型"><a href="#2-队列模型" class="headerlink" title="2.队列模型"></a><strong>2.队列模型</strong></h3><p>在NS3的原有队列模型中使用的是丢尾队列，当发送数据包的队列已满时，丢尾队列会丢弃队列的最后的数据包，以控制数据包的发送率，我们引入了丢头队列，即当队列已满时，主动丢弃队列的头部的数据包，因为当队列已满时，表明队列的头部数据包非常的大，导致发送时间过长，使得后面的数据包处于等待过程中。因此丢头队列机制也会使得数据包的发送速率提升。</p><h3 id="3-定向网络"><a href="#3-定向网络" class="headerlink" title="3.定向网络"></a><strong>3.定向网络</strong></h3><p>在NS3现有的模型中,无线网络采用的时广播的方式，中心节点发送数据之后，其余的节点都会收到数据包，我们引入了定向网路的模型，即在显示场景中，通过摆放天线的朝向，可以定向的向部分节点发送数据，两者对比如图：</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E4%B8%89%EF%BC%9A%E5%AE%9A%E5%90%91%E7%BD%91%E7%BB%9C%E5%92%8C%E9%9D%9E%E5%AE%9A%E5%90%91%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%AF%94.png" alt="图三：定向网络和非定向网络对比"></p><p>图三：定向网络和非定向网络对比</p><p>在NS3中构造如上图所示的场景，在定向网络中只有定向的节点才会收到数据包，其余节点则不回收到数据包，而在非定向网络中，则是全部节点都会收到数据包，因此在两种场景下统计各个节点收到的数据包的数量就可以对比两者的特性。</p><h3 id="4-固定争用"><a href="#4-固定争用" class="headerlink" title="4.固定争用"></a><strong>4.固定争用</strong></h3><p>实际场景中，在可传输的范围内，随着用户数量的增多，用户之间发生冲突的几率会逐渐增加，网络的性能将会逐渐下降，吞吐量逐渐下降，丢包率逐渐上升。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%9B%9B%EF%BC%9A%E5%9B%BA%E5%AE%9A%E4%BA%89%E7%94%A8.png" alt="图四：固定争用"></p><p>如图所示，仍然采用错误模型中的节点分布，中心节点向周围节点发送数据，同时不断扩大冲突范围，随着冲突范围的不断扩大，覆盖的用户数量就会不断的增加，吞吐量应该会逐渐下降，因此统计各个节点的丢包率应该会观察到随着冲突范围的增加，丢包率在逐渐上升。</p><h2 id="四、实验过程"><a href="#四、实验过程" class="headerlink" title="四、实验过程"></a><strong>四、实验过程</strong></h2><h3 id="1-错误模型测试"><a href="#1-错误模型测试" class="headerlink" title="1.错误模型测试"></a><strong>1.错误模型测试</strong></h3><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E4%BA%94%EF%BC%9A%E8%8A%82%E7%82%B9%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="图五：节点分布图"></p><p>采用如图五中的节点分布，一共有101个节点，节点0在中心，另外一百个节点随机分布在半径为100的圆内，令中心节点向周围节点发送数据，统计各个节点收到的数据包。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%85%AD-%E6%B5%8B%E8%AF%95%E6%89%80%E5%BE%97%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png" alt="图六:测试所得丢包率曲线"></p><p>采用所构造的错误模型曲线，统计丢包率，测试结果如图六所示，测试结果显示随着距离的增加，丢包率在逐渐的上升，因此符合预期要求。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E4%B8%83-%E6%B5%8B%E8%AF%95%E6%89%80%E5%BE%97%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png" alt="图七:测试所得丢包率曲线"></p><p>另一方面，减少节点数量为21个，统计统计节点的收包特性图，如图七所示，图中绿色的部分表明节点正在收到数据包，其余表示因发生错误导致节点处于空闲状态，结果表明由于节点所处的距离不同，任何两个节点的收包特性是不一样的，因此也从另一方面验证了所构造的模型的合理性和正确性。</p><h3 id="2-数据包队列测试"><a href="#2-数据包队列测试" class="headerlink" title="2.数据包队列测试"></a><strong>2.数据包队列测试</strong></h3><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%85%AB-%E4%B8%A2%E5%A4%B4%E9%98%9F%E5%88%97%E5%92%8C%E4%B8%A2%E4%B8%BA%E9%98%9F%E5%88%97.png" alt="图八:丢头队列和丢为队列"></p><p>采用两种类型的队列机制:丢头队列和丢为队列，测试的机制如图八所示，一共有两个节点，节点0向节点1发送数据包，并分别采用两种队列机制，然后统计节点1的收包特性。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E4%B9%9D-%E6%B5%8B%E8%AF%95%E6%89%80%E5%BE%97%E4%B8%A2%E5%8C%85%E7%8E%87%E6%9B%B2%E7%BA%BF.png" alt="图九:测试所得丢包率曲线"></p><p>如图所示为测试结果，测试结果表明，丢头队列和丢尾队列都可以改变丢包率，并且可以看出丢头队列的延迟比丢尾队列的延迟更小。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%8D%81-%E9%98%9F%E5%88%97%E4%BC%98%E5%85%88%E7%BA%A7%E6%B5%8B%E8%AF%95%E6%9B%B2%E7%BA%BF.png" alt="图十:队列优先级测试曲线"></p><p>如图所示曲线为队列有限级的测试曲线，所发送的数据包分为数据包和控制包</p><h3 id="3-定向传输测试"><a href="#3-定向传输测试" class="headerlink" title="3.定向传输测试"></a><strong>3.定向传输测试</strong></h3><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%8D%81%E4%B8%80-%E5%AE%9A%E5%90%91%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B.png" alt="图十一:定向传输测试模型"></p><p>上图为测试定向网络时的节点分布图，其中节点1，3，4，7，10，11为定向网络节点，当使用定向网络传输模式时，中心节点0向这些节点定向传输数据，其余节点则应不能收到数据包，而当使用非定向网络传输模式时，所有节点都应该可以收到数据包。</p><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%8D%81%E4%BA%8C-%E5%AE%9A%E5%90%91%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="图十二:定向传输测试结果"></p><p>测试结果如上图，蓝色为非定向网络，黄色为定向网络，结果表明，当使用非定向网络时，全部节点都可以收到数据包，当使用定向网络时，只有定向网络节点才可以收到数据包，非定向网络节点无法收到数据包。</p><h3 id="4-固定争用测试"><a href="#4-固定争用测试" class="headerlink" title="4.固定争用测试"></a><strong>4.固定争用测试</strong></h3><p><img src="https://delta1037.oss-cn-beijing.aliyuncs.com/notion2hexo/School_%E5%9F%BA%E4%BA%8ENS3%E7%9A%84%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%A9%E7%90%86%E5%B1%82%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C_%E5%9B%BE%E5%8D%81%E4%B8%89%EF%BC%9A%E5%9B%BA%E5%AE%9A%E4%BA%89%E7%94%A8%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="图十三：固定争用测试结果"></p><p>如图所示，横轴为冲突范围所覆盖的用户数量，测试结果表明：随着冲突范围的不断扩大，覆盖的用户数量逐渐增多，因此导致的冲突逐渐增多，丢包率逐渐上升，收包率逐渐下降。</p><h2 id="五、实验小结"><a href="#五、实验小结" class="headerlink" title="五、实验小结"></a><strong>五、实验小结</strong></h2><p>实验过程中，我们遇到了很多的问题，首先在实验环境的搭建过程中，刚开始搭建的是基于NS3-dev的环境，在代码测试的过程中遇到了很多的问题，之后又搭建了NS3-dce的环境进行测试。同时，在测试代码的时候也有很多的问题，由于机器的处理速度有限，仿真测试结果往往需要很长时间才会出来，也花费了我们很多的精力。  在之后的过程中，我们将继续改进这个模型，构建宏基站和微基站的体系架构，并在此架构上面探索单小区模型和大规模网络场景模型下的基站调度策略。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于NS3的无线链路物理层仿真实验&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="https://www.delta1037.cn/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="NS3" scheme="https://www.delta1037.cn/tags/NS3/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发笔记</title>
    <link href="https://www.delta1037.cn/2018/School/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.delta1037.cn/2018/School/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2025-09-07T10:48:04.794Z</updated>
    
    <content type="html"><![CDATA[<p>敏捷开发笔记</p><span id="more"></span><h3 id="敏捷知识基础"><a href="#敏捷知识基础" class="headerlink" title="敏捷知识基础"></a><strong>敏捷知识基础</strong></h3><ul><li>迭代计划会议、迭代验收会议、每日站立会议、迭代回顾会议</li><li>聚焦客户价值，激发团队潜能、适应变化</li><li>自动化、变化的需求</li></ul><h1 id="story"><a href="#story" class="headerlink" title="story"></a><strong>story</strong></h1><ul><li>故事描述了对于系统或软件的客户或用户有价值的一个功能点</li><li>组成<ul><li>简短描述</li><li>针对故事描述交流，澄清细节</li><li>记录和传递故事细节的测试信息，用来确定故事是否开发完成</li></ul></li><li>格式：<ul><li>作为X（什么用户角色</li><li>为了Y（目的</li><li>希望得到什么（系统提供什么功能</li></ul></li><li>3-3-4<ul><li>三个角色：PO、master、开发人员</li><li>三个工件：</li><li>产品清单</li><li>迭代清单</li><li>燃尽图</li><li>四个会议</li></ul></li><li>收集story<ul><li>价值分析</li><li>识别用户角色</li><li>编写story</li><li>确定优先级</li><li>估计</li></ul></li><li>分解Story<ul><li>分解原则：每个格式提供相对完整的功能</li></ul></li><li>好的story<ul><li>独立</li><li>便于沟通</li><li>有价值</li><li>易于估计</li><li>可测试</li></ul></li></ul><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a><strong>持续集成</strong></h2><ul><li>持续集成工作产品，一天集成多次，每次集成有自动化的测试环境（包含测试）</li></ul><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a><strong>测试驱动开发</strong></h2><ul><li>快速新增测试</li><li>运行所有测试</li><li>做改动</li><li>所有测试通过</li><li>重构，消除重复设计，设计优化结构</li></ul><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a><strong>测试用例</strong></h2><ul><li>快速：测试运行够快</li><li>独立用例之间互相独立</li><li>可重复：任何环境、可重复</li><li>自足验证：足够的自动化测试验证逻辑</li><li>及时：及时写测试用例</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;敏捷开发笔记&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="敏捷开发" scheme="https://www.delta1037.cn/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2018</title>
    <link href="https://www.delta1037.cn/2018/Times/2018/"/>
    <id>https://www.delta1037.cn/2018/Times/2018/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2025-09-07T10:48:04.795Z</updated>
    
    <content type="html"><![CDATA[<p>To 2018</p><span id="more"></span><ul><li>不要老是宅在学校，老是看书看漫画动漫。。。武汉的那些奇奇怪怪的街，或许很有趣呢，，，倒是出去过几次，走在繁华的街上，人来人往，有几丝惊恐，算了编不下去了。。。下次勇敢点! 是这座城接纳不了自己，还是自己接纳不了这座城。</li><li>哦～ 下学期要好好听课……这学期废了，听课率估计不到1%，期末预习真的是鸭梨大，，，</li><li>不要老是去想一些乱七八糟的事情，好好规划自己，虽然不想被灌输一些奇怪的知识，但还是要收拾好自己，知道自己要做什么</li><li>怎么感觉和别人老是沟不通呢……难道是API有问题么，，，</li><li>找找心在哪咯，，，</li></ul><blockquote><p>就酱，就这些。。。 最近好像能看懂诗集了，，语文老师看到这儿…肯定会大吃一鲸的吧…… 等会儿复制下再圈个重点&#x2F;&#x2F;期末预习过度后遗症 谢谢大佬送的肯德基日历～</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;To 2018&lt;/p&gt;</summary>
    
    
    
    <category term="时光" scheme="https://www.delta1037.cn/categories/%E6%97%B6%E5%85%89/"/>
    
    
    <category term="时光" scheme="https://www.delta1037.cn/tags/%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>短信收发功能分析</title>
    <link href="https://www.delta1037.cn/2018/School/%E7%9F%AD%E4%BF%A1%E6%94%B6%E5%8F%91%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>https://www.delta1037.cn/2018/School/%E7%9F%AD%E4%BF%A1%E6%94%B6%E5%8F%91%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2025-09-07T10:48:04.689Z</updated>
    
    <content type="html"><![CDATA[<p>短信接收与发送功能分析</p><span id="more"></span><ul><li><em>华中科技大学</em></li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>本文主要介绍了短信的发送与接收功能，其中包含发信端向短信中心发送短信的过程、短信中心相互转发短信的过程，短信中心向收件人发送短信的过程，具体介绍了这三者之间的连接过程和网关在这三者之间的作用；此外介绍了短信中心的存储转发模式、网关、寄存器、移动交换中心、如何确认收件人的位置和不同的传输模式，具体介绍了网关在安全性方面的作用和短信发送所采用的协议；然后，简单介绍了短信的几种加密算法，并分析了算法的原理和不安全性体现；最后介绍了短信的发展过程，及其在发送内容方面的进步，和各种短信业务的分类及其简单介绍了在发送过程中路线的不同。 <strong>关键词：短信 发送 接收 短信协议 加密算法 短信发展</strong></p><h2 id="1-短信的发送与接收"><a href="#1-短信的发送与接收" class="headerlink" title="1.短信的发送与接收"></a><strong>1.短信的发送与接收</strong></h2><h3 id="1-1手机编辑短信发送到短信中心"><a href="#1-1手机编辑短信发送到短信中心" class="headerlink" title="1.1手机编辑短信发送到短信中心"></a><strong>1.1手机编辑短信发送到短信中心</strong></h3><h3 id="1-1-1从手机编辑短信到发送到短信中心的大体流程"><a href="#1-1-1从手机编辑短信到发送到短信中心的大体流程" class="headerlink" title="1.1.1从手机编辑短信到发送到短信中心的大体流程"></a><strong>1.1.1从手机编辑短信到发送到短信中心的大体流程</strong></h3><p>首先发送端编辑短信，并且填写收件人的号码，然后手机内的芯片对文字信息进行编码，向串口写相应的AT指令，然后将信息传递到基带，由调制解调器调制成电磁波，最后该电磁波发送到短信中心。</p><h3 id="1-1-2客户端与短信中心验证流程"><a href="#1-1-2客户端与短信中心验证流程" class="headerlink" title="1.1.2客户端与短信中心验证流程"></a><strong>1.1.2客户端与短信中心验证流程</strong></h3><p>a．首先MS向MSC发起接入请求，其中包含MS的IMSI或TMSI号码；b，MSC向VLR发起接入请求，VLR在接入处理过程中可进行鉴权和加密；c，VLR向MSC回送接入证实消息；d，MSC向MS回送接入证实消息，允许MS进入GSM网络通讯；e，MS向MSC发送一条短消息，其中包含短消息的内容、目的SC地址；f，MSC向VLR查询MS是否可以发送短消息；g，VLR在确认MS具有短消息业务且没有被禁止后，通知MSC当前MS可以发送短消息，并提供MSISDN号码；h，MSC向IWMSC转发短消息，其中包含该条短消息的内容、源MS的MSISDN号码、目的SC地址；i，IWMSC向SC转发短消息，其中包含该条短消息的内容、源MS的MSISDN号码、目的SC地址；j，SC通知IWMSC已接受短消息；k，IWMSC通知MSC已接收短消息；l，MSC通知MS短消息发送成功。</p><h3 id="1-1-3短信编码的规则"><a href="#1-1-3短信编码的规则" class="headerlink" title="1.1.3短信编码的规则"></a><strong>1.1.3短信编码的规则</strong></h3><p>对短信参数进行ＰＤＵ（ｐｒｏｔｏｃｏｌ　ｄａｔａ　ｕｎｉｔ）格式的编码，短信经过十六进制的编码后进行传送，其中不仅包含了消息字符，还包含了许多元数据，比如短信中心地址、字符编码格式、时间戳等</p><h3 id="1-1-4关于短信字符的限制"><a href="#1-1-4关于短信字符的限制" class="headerlink" title="1.1.4关于短信字符的限制"></a><strong>1.1.4关于短信字符的限制</strong></h3><p>无论何时使用SS7协议的移动应用部分（MAP），SMSC和手机之间都会发送短消息。消息与MAP MO-和MT-ForwardSM操作，其有效载荷长度由信令协议的约束所限制发送以精确地140 个字节（140个字节×8比特&#x2F;字节&#x3D; 1120个比特），单条短信采用７位编码时最长可达１６０个字符，对于中文字符需要１６位编码，因此实际能发送的文本只有７０个字符，过长的短信会进行分割发送</p><h3 id="1-2从短信中心到短信中心的转发"><a href="#1-2从短信中心到短信中心的转发" class="headerlink" title="1.2从短信中心到短信中心的转发"></a><strong>1.2从短信中心到短信中心的转发</strong></h3><h3 id="1-2-1从短信中心到短信中心转发的大体过程"><a href="#1-2-1从短信中心到短信中心转发的大体过程" class="headerlink" title="1.2.1从短信中心到短信中心转发的大体过程"></a><strong>1.2.1从短信中心到短信中心转发的大体过程</strong></h3><p>首先短信中心对收到的信息进行初次解码，来确定收件人的号码和其他关键信息，然后以此来查找收件人的位置，然后将该短信发送到收件人所在位置的短信中心</p><h3 id="1-2-2-短信中心的存储转发模式"><a href="#1-2-2-短信中心的存储转发模式" class="headerlink" title="1.2.2 短信中心的存储转发模式"></a><strong>1.2.2 短信中心的存储转发模式</strong></h3><p>短信发出后先存储在ＳＭＳＣ（短信服务中心，ｓｈｏｒｔ　ｍｅｓｓａｇｅ　ｓｅｒｖｉｃｅ　ｃｅｎｔｅｒ），然后由短信中心将短信信息发送给接收方，如果接收方不在服务区，ＳＭＳＣ就会自动保存该信息，等到接收方出现在服务区时再发送</p><h3 id="1-2-3-网关（SMCGMSC）的作用"><a href="#1-2-3-网关（SMCGMSC）的作用" class="headerlink" title="1.2.3 网关（SMCGMSC）的作用"></a><strong>1.2.3 网关（SMCGMSC）的作用</strong></h3><p>获取来自SMSC传递的短消息，通过HLR读取路由信息，符合传送条件后，将SMS消息发送给收件人所处的基站</p><h3 id="1-2-4归属地位置寄存器（HLR）"><a href="#1-2-4归属地位置寄存器（HLR）" class="headerlink" title="1.2.4归属地位置寄存器（HLR）"></a><strong>1.2.4归属地位置寄存器（HLR）</strong></h3><p>归属地位置寄存器，用于存放和管理移动用户的相关信息，移动设备所在位置信息同样保存在HLR，HLR每隔一段时间就会记录位置信息，采用这样的机制，当进行服务时可以迅速查到收件人</p><h3 id="1-2-5移动交换中心（MSC）"><a href="#1-2-5移动交换中心（MSC）" class="headerlink" title="1.2.5移动交换中心（MSC）"></a><strong>1.2.5移动交换中心（MSC）</strong></h3><p>移动交换中心，管控数据的连接与传送，当用户从一个服务区转至另一个服务区时，可以对区域进行切换</p><h3 id="1-2-6-关于收件人位置的确定"><a href="#1-2-6-关于收件人位置的确定" class="headerlink" title="1.2.6 关于收件人位置的确定"></a><strong>1.2.6 关于收件人位置的确定</strong></h3><p>尽管您没有使用手机打电话，您的手机也在不停地发送和接收着信息。它通过被称为控制通道的通路与手机发射塔进行通信。这种通讯的目的是让手机系统了解自己所在的信号区域，以便在您移动时，手机可以切换到其他信号区域。每隔一段时间，手机和发射塔将交换数据包以确定一切工作正常。</p><h3 id="1-2-7-跨网传输与同网传输"><a href="#1-2-7-跨网传输与同网传输" class="headerlink" title="1.2.7 跨网传输与同网传输"></a><strong>1.2.7 跨网传输与同网传输</strong></h3><p>跨网传输：不同运营商的短信中心之间相互发送，首先发信人先将信息发送到收信人运营商的短信中心，发送人运营商的短信中心将信息发送给收信人运营商的短信中心，收信人的短信中心再将该信息发送给收信人。 同网传输：相同运营商的短信中心之间互相发送，首先发信人将信息发送到短信中心，短信中心再将该信息发送给收信人。</p><h3 id="1-3从短信中心到发送到收件人的手机中"><a href="#1-3从短信中心到发送到收件人的手机中" class="headerlink" title="1.3从短信中心到发送到收件人的手机中"></a><strong>1.3从短信中心到发送到收件人的手机中</strong></h3><h3 id="1-3-1从短信中心到发送到收件人手机的大体过程"><a href="#1-3-1从短信中心到发送到收件人手机的大体过程" class="headerlink" title="1.3.1从短信中心到发送到收件人手机的大体过程"></a><strong>1.3.1从短信中心到发送到收件人手机的大体过程</strong></h3><p>用户手机定时器触发开始读串口数据进行判断，当串口没有数据时，等待下一次定时器触发；当短信中心向收件人发送电磁波即串口有数据时，将串口的数据读入，然后收件人对收到的数据进行解码，最后对PDU编码的数据解析成文本，在手机端以UI界面显示</p><h3 id="1-3-1接收端与短信中心的相互验证流程"><a href="#1-3-1接收端与短信中心的相互验证流程" class="headerlink" title="1.3.1接收端与短信中心的相互验证流程"></a><strong>1.3.1接收端与短信中心的相互验证流程</strong></h3><p>a, SC向GMSC发送短消息，其中包含短消息的内容、源SC地址、目的MS的MSISDN号码，另外还有SC存在短消息等待发送标识；b. GMSC向目的MS所属的HLR查询路由信息；c, HLR向GMSC返回查询结果，有两种情况：成功，返回路由信息其中包含目的MS所在的MSC号码，以及目的用户的IMSI、LMSI号码;;失败，返回错误原因，可能同时返回Alert_MSISDN号码。d. GMSC根据获得的路由信息向目的MSC发送短消息，其中包含短消息内容、源SC地址、目的MS的IMSI或LMSI号码；e. MSC向VLR查询目的MS的相关信息，包括MS是否可及等标志位；f. VLR向MSC发送寻呼请求消息，要求建立无线连接；g. MSC收到VLR的寻呼请求后，向MS发送寻呼请求；h. MS寻呼成功，进行接入过程；i. MSC发送接入请求消息通知VLR寻呼成功；j. VLR完成对MS的鉴权、数据的更新以及加密等操作后，通知MSC接入成功；k. MSC向MS发送接入证实消息；l. MSC向MS转发短消息，其中包括短消息内容和源SC地址；m. MS向MSC返回短消息成功接收消息；n. MSC通知GMSC，MS已成功接收短消息；o. GMSC通知SC，MS已成功接收短消息。行判断；当数据中有新短信的提示符时，按照ＰＤＵ短信的解码格式对该短信进行解码，并调用ＵＩ界面提示新短信到达</p><h3 id="1-4短信的双向传输模式"><a href="#1-4短信的双向传输模式" class="headerlink" title="1.4短信的双向传输模式"></a><strong>1.4短信的双向传输模式</strong></h3><p>ＳＭＳ对发送的消息进行可靠的双向传输，即ＳＭＳ发送消息后会受到确认信息，获得发送的结果，对于不同的结果即发送成功或者发送失败会显示不同的信息给发送方</p><h3 id="1-5短信的传输同步功能"><a href="#1-5短信的传输同步功能" class="headerlink" title="1.5短信的传输同步功能"></a><strong>1.5短信的传输同步功能</strong></h3><p>ＳＭＳ传输的同步性，即ＳＭＳ可以与数据、语音等业务一起进行同步传输，即便在业务信道数据量处于高峰时也能保证信息的顺利发送</p><h3 id="1-6短信的PTP模式"><a href="#1-6短信的PTP模式" class="headerlink" title="1.6短信的PTP模式"></a><strong>1.6短信的PTP模式</strong></h3><p>Ｐｅｅｒ　ｔｏ　ｐｅｅｒ的通信方式，发送方只需要知道对方的手机号码，就可以给对方发送信息，就先计算机的ｉｐ地址一样，一旦绑定，就可以通过该地址与其他地址建立连接</p><h3 id="1-7-无状态通信"><a href="#1-7-无状态通信" class="headerlink" title="1.7 无状态通信"></a><strong>1.7 无状态通信</strong></h3><p>SMS是一种无状态通信协议，其中每个SMS消息被认为完全独立于其他消息。使用SMS作为有状态对话（其中MO应答消息与特定MT消息配对）的通信信道的企业应用要求会话管理在协议外部维护</p><h3 id="1-8-短信所采用的协议"><a href="#1-8-短信所采用的协议" class="headerlink" title="1.8 短信所采用的协议"></a><strong>1.8 短信所采用的协议</strong></h3><h3 id="1-8-1-协议名称"><a href="#1-8-1-协议名称" class="headerlink" title="1.8.1 协议名称"></a><strong>1.8.1 协议名称</strong></h3><p>ＳＭＰＰ（ｓｈｏｒｔ　ｍｅｓｓａｇｅ　ｐｅｅｒ　ｔｏ　ｐｅｅｒ　ｐｒｏｔｏｃｏｌ），对等短信信息协议</p><h3 id="1-8-2-协议的功能"><a href="#1-8-2-协议的功能" class="headerlink" title="1.8.2 协议的功能"></a><strong>1.8.2 协议的功能</strong></h3><p>1）定义了外部短信信息实体ＥＳＭＥ与短信息中心ＳＭＳＣ的数据通信接口 2）在ＥＳＭＥ和ＳＭＳＣ之间定义一系列的短信息交换操作 3）在ＥＳＭＥ和ＳＭＳＣ之间定义ＥＳＭＥ和ＳＭＳＣ交换的数据格式</p><h3 id="1-8-3-各个运营商对协议的拓展"><a href="#1-8-3-各个运营商对协议的拓展" class="headerlink" title="1.8.3 各个运营商对协议的拓展"></a><strong>1.8.3 各个运营商对协议的拓展</strong></h3><p>各运营商基于ＳＭＰＰ协议开发了适合自己的协议标准：中国移动的ＣＭＰＰ协议，中国联通的ＳＧＩＰ协议，中国电信的ＳＭＧＰ协议</p><h3 id="1-9-短信的发送与接收"><a href="#1-9-短信的发送与接收" class="headerlink" title="1.9 短信的发送与接收"></a><strong>1.9 短信的发送与接收</strong></h3><p>手机的信号频率很高，一般在900Mhz左右，靠电离层反射传播，打电话的手机信号传到最近的基站，也就是移动或者连通的信号塔，再由基站把高频信号频率降低，由基站和基站之间通信，这个信号是直线传播，遇到高的建筑物会被挡住，所以那些塔都竖的很高，传到接电话的手机附近的基站，再转成高频信号发给手机。</p><h3 id="1-10-短信网关"><a href="#1-10-短信网关" class="headerlink" title="1.10 短信网关"></a><strong>1.10 短信网关</strong></h3><h3 id="1-10-1-短信网关简介"><a href="#1-10-1-短信网关简介" class="headerlink" title="1.10.1 短信网关简介"></a><strong>1.10.1 短信网关简介</strong></h3><p>短信网关ISMG全称Internet Short Message Gateway，主要是为了解决各网络、各运营商之间的短信互通和SP的接入问题。它为使用单位收发短信而提供的一个动态数据交换平台系统。通过该系统的接口软件，可以将短信平台与各种系统和软件进行无缝高效相连，将应用单位的系统随时产生的动态信息转变成手机短信，通过梦网平台连接移动和联通的短信中心以端口特服号码进行实时中发送和接受，为各种系统（或软件）建立一个快速的短信双向（或单向）通道，以便手机用户采用短信方式与SP双向通信，接收SP提供的信息服务。</p><h3 id="1-10-2-短信网关的组成及其功能"><a href="#1-10-2-短信网关的组成及其功能" class="headerlink" title="1.10.2 短信网关的组成及其功能"></a><strong>1.10.2 短信网关的组成及其功能</strong></h3><p>短信网关各组成部分的功能为： （1）SMPP代理系统遵循SMPP 3.3版本协议与GSM网中短消息中心连接，实现高效、可靠的数据传输。该系统支持流量控制功能，能够根据SMSC的业务量进行发送流量控制。 （2）通信代理系统实现与SP等内容供应商的连接和协议互通。它基于TCP&#x2F;IP协议基础之上，利用CMPP协议与SP之间建立一条安全、高效的传输通道。该系统支持流量控制功能，能够根据本身的业务量进行接收流量控制。 （3）防火墙作为短信网关的重要功能组成部分，其功能是对短信网关内部其它相关模块进行保护，实现针对内外访问的包过滤和代理。 （4）短消息网关处理系统完成网关的业务处理，包括：向汇接网关进行路由查询，在本地建立短信网关ID、用户手机号码、SP ID及其IP地址对应表的缓存，建立用户手机号码段与SMSC（短信中心）地址的对应表，完成对数据分发功能的支持、计费原始话单的提供及处理等。 （5）短信网关计费系统提供短信网关的原始话单记录（CDR）。 （6）业务管理系统包括业务管理和网关监控功能。</p><h3 id="1-10-3-短信网关与短信中心的连接"><a href="#1-10-3-短信网关与短信中心的连接" class="headerlink" title="1.10.3 短信网关与短信中心的连接"></a><strong>1.10.3 短信网关与短信中心的连接</strong></h3><p>短信网关与短信中心之间应采用专线方式互联</p><h3 id="1-10-4-短信网关的安全性"><a href="#1-10-4-短信网关的安全性" class="headerlink" title="1.10.4 短信网关的安全性"></a><strong>1.10.4 短信网关的安全性</strong></h3><p>短信网关在硬件和软件结构设计上应采用分布式、模块化的设备，其中硬件设备可考虑采用多台主机，在网络上利用四层交换机实现负载分担工作，避免单点故障，实现设备的安全。 同时短信网关采用防火墙技术，可以支持IP包过滤和应用代理方式，防止外界的攻击，实现信息的安全。 短信网关与SP在进行CMPP协议的连接建立时，采用MD5对互相的身份进行认证，实现业务的安全。 短信网关与短信中心、计费中心之间的连接都采用专线方式，而且与计费中心的连接还要求计费中心侧加入防火墙，保障了现网设备的安全性不会由于与短信网关的连接而降低。</p><h2 id="2-短信的安全性"><a href="#2-短信的安全性" class="headerlink" title="2.短信的安全性"></a><strong>2.短信的安全性</strong></h2><h3 id="2-1-GSM标准的加密算法"><a href="#2-1-GSM标准的加密算法" class="headerlink" title="2.1 GSM标准的加密算法"></a><strong>2.1 GSM标准的加密算法</strong></h3><p>对于ＧＳＭ标准所使用的加密算法，短信的安全性已经被证实是不堪一击的，通过暴力破解可在２的３２次方时间内解出短信的具体内容，</p><h3 id="2-2-GSM算法的改进"><a href="#2-2-GSM算法的改进" class="headerlink" title="2.2 GSM算法的改进"></a><strong>2.2 GSM算法的改进</strong></h3><p>可以使用强加密的ＣＤＭＡ标准，用于保密信息的传输</p><h3 id="2-3-A5-x2F-1算法"><a href="#2-3-A5-x2F-1算法" class="headerlink" title="2.3 A5&#x2F;1算法"></a><strong>2.3 A5&#x2F;1算法</strong></h3><h3 id="2-3-1-算法简介"><a href="#2-3-1-算法简介" class="headerlink" title="2.3.1 算法简介"></a><strong>2.3.1 算法简介</strong></h3><p>A5 &#x2F; 1是用来产生为每个脉冲串的114位序列的密钥流被进行异或之前调制与114位。A5 &#x2F; 1使用一个64位的密钥和一个公认的22位帧号进行初始化。使用Comp128v1进行密钥生成的老式GSM实现有10个密钥位固定为零，从而产生有效的密钥长度的54位。这个弱点通过Comp128v2的引入得到纠正，该Comp128v2产生适当的64位密钥。</p><h3 id="2-3-2-算法的破解"><a href="#2-3-2-算法的破解" class="headerlink" title="2.3.2 算法的破解"></a><strong>2.3.2 算法的破解</strong></h3><p>利用了GSM通信加密中的两个安全漏洞，并且在普通商用硬件的帮助下，花费了55天的时间计算出了一个彩虹表。这个彩虹表的大小为984GB。得到了彩虹表之后，安全专家就可以在短短的九秒内确定用于加密通信数据的密钥了。</p><h3 id="2-4-A5-x2F-2算法"><a href="#2-4-A5-x2F-2算法" class="headerlink" title="2.4 A5&#x2F;2算法"></a><strong>2.4 A5&#x2F;2算法</strong></h3><p>密码基于四个带有不规则时钟的线性反馈移位寄存器和一个非线性组合器的组合</p><h3 id="2-5-A5-x2F-3算法（KASUMI）"><a href="#2-5-A5-x2F-3算法（KASUMI）" class="headerlink" title="2.5 A5&#x2F;3算法（KASUMI）"></a><strong>2.5 A5&#x2F;3算法（KASUMI）</strong></h3><p>KASUMI算法在3GPP技术规范中规定。KASUMI是128位密钥和64位输入和输出的分组密码。KASUMI的核心是一个八轮Feistel网络。主要Feistel网络中的轮函数是不可逆的类Feistel网络变换。在每一轮中，循环函数都使用一个循环密钥，该循环密钥由使用固定密钥调度从原始128位密钥导出的八个16位子密钥组成。</p><h3 id="2-6-短信不安全方面"><a href="#2-6-短信不安全方面" class="headerlink" title="2.6 短信不安全方面"></a><strong>2.6 短信不安全方面</strong></h3><p>a.通过固定网络传输的通信数据没有受到加密保护；b.无法抵御某些主动攻击；c.只有连接至安全的固定网络才可以保证GSM的通信安全；d.GSM中的合法拦截只是一种事后补救措施；e.终端识别码不可信任。</p><h2 id="3-短信的发展及其分类"><a href="#3-短信的发展及其分类" class="headerlink" title="3.短信的发展及其分类"></a><strong>3.短信的发展及其分类</strong></h2><h3 id="3-１．SMS短信"><a href="#3-１．SMS短信" class="headerlink" title="3.１．SMS短信"></a><strong>3.１．SMS短信</strong></h3><p>仅支持发送文本，根据发送对象和客户是否处理漫游状态，基础短信业务可分为网内点对点短信、网间点对点短信、国际短信、短信国际漫游。</p><h3 id="3-2-移动梦网短信业务"><a href="#3-2-移动梦网短信业务" class="headerlink" title="3.2. 移动梦网短信业务"></a><strong>3.2. 移动梦网短信业务</strong></h3><p>移动梦网短信业务是移动梦网服务的重要组成部分，是中国移动向客户提供的基于移动梦网短信平台的数据应用服务总称。移动梦网短信业务由与中国移动签约的合作伙伴提供，目前已接入数百家内容提供商（简称SP），提供了数万种业务。</p><h3 id="3-3．EMS短信"><a href="#3-3．EMS短信" class="headerlink" title="3.3．ＥＭＳ短信"></a><strong>3.3．ＥＭＳ短信</strong></h3><p>可以支持发送格式文本、音效、小型图片、以及照片。其中音效是语音短信业务，语音短信业务是指把你想说的话语通过固定电话、小灵通或者手机进行录音，发给一个或多个用户进行收听你的留言，同时，你还可以根据电话的提示音，进行语音短信的接收、转发、查询、回复和语音短信点播等操作。它弥补了传统的文字短信难以传递声音和信息输入不便的缺憾，解决了那些因为不熟悉拼音使用，长时间徘徊在短信之外的人们发送短信的难题，也有效地解决了电话、小灵通或手机与之间发送短信的互联互通问题。</p><h3 id="3-4．MMS彩信"><a href="#3-4．MMS彩信" class="headerlink" title="3.4．ＭＭＳ彩信"></a><strong>3.4．ＭＭＳ彩信</strong></h3><p>可以支持文本短信息、动画、音频、视频文件。彩信的英文名是MMS，它是Multimedia Messaging Service的缩写，意为多媒体信息服务，通常又称为彩信。它最大的特色就是支持多媒体功能，能够传递功能全面的内容和信息，这些信息包括文字、图像、声音、数据等各种多媒体格式的信息。 彩信在技术上实际并不是一种短信，而是在GPRS网络的支持下，以WAP无线应用协议为载体传送图片、声音和文字等信息。彩信业务可实现即时的手机端到端、手机终端到互联网或互联网到手机终端的多媒体信息传送。</p><h2 id="4-短信业务的分类"><a href="#4-短信业务的分类" class="headerlink" title="4.短信业务的分类"></a><strong>4.短信业务的分类</strong></h2><h3 id="１．网内点对点通信"><a href="#１．网内点对点通信" class="headerlink" title="１．网内点对点通信"></a><strong>１．网内点对点通信</strong></h3><p>用户在手机上编辑信息内容，输入对方手机号码，选择发送将一条短信发送到接收方手机的短信业务，单条最大长度为140个字节，或者70个中文字符</p><h3 id="２．网间短信业务"><a href="#２．网间短信业务" class="headerlink" title="２．网间短信业务"></a><strong>２．网间短信业务</strong></h3><p>中国移动和中国联通实现短信的互联互通，移动用户和联通用户可通过手机发送短信</p><h3 id="３．国际短信"><a href="#３．国际短信" class="headerlink" title="３．国际短信"></a><strong>３．国际短信</strong></h3><p>中国移动和全球89个国家和地区的134个移动运营商实现了短信互通，即移动用户可以和港澳台、东南亚、北美、南美等国家和地区的主要移动运营商的用户收发短信</p><h3 id="４．短信国际漫游"><a href="#４．短信国际漫游" class="headerlink" title="４．短信国际漫游"></a><strong>４．短信国际漫游</strong></h3><p>中国移动用户漫游与中国移动签署了GSM漫游协议的国家和地区后，可以使用当地移动网络和国内移动用户收发短信</p><h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5.参考文献"></a><strong>5.参考文献</strong></h2><ul><li>[1] 维基百科SMS <a href="https://en.wikipedia.org/wiki/SMS">https://en.wikipedia.org/wiki/SMS</a></li><li>[2] 互动百科 短信<a href="http://www.baike.com/wiki/%E7%9F%AD%E4%BF%A1">http://www.baike.com/wiki/%E7%9F%AD%E4%BF%A1</a></li><li>[3] 维基百科 KASUMI算法 <a href="https://en.wikipedia.org/wiki/KASUMI">https://en.wikipedia.org/wiki/KASUMI</a></li><li>[4] 智能手机电话短信实验模块设计<a href="http://rf.eefocus.com/article/id-257105">http://rf.eefocus.com/article/id-257105</a></li><li>[5] 短信平台在移动办公中的设计与实现<a href="https://wenku.baidu.com/view/91d83d987f1922791788e800.html">https://wenku.baidu.com/view/91d83d987f1922791788e800.html</a></li><li>[6] 多媒体短信<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94%E7%9F%AD%E8%A8%8A">https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94%E7%9F%AD%E8%A8%8A</a></li><li>[7] 移动CMPP通信原理及短信协议解析<a href="https://wenku.baidu.com/view/53dba4ee9b89680203d82549.html?re=view">https://wenku.baidu.com/view/53dba4ee9b89680203d82549.html?re=view</a></li><li>[8] 移动网络名词理解<a href="http://m.blog.csdn.net/karen_wang/article/details/7650433">http://m.blog.csdn.net/karen_wang&#x2F;article&#x2F;details&#x2F;7650433</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;短信接收与发送功能分析&lt;/p&gt;</summary>
    
    
    
    <category term="课程" scheme="https://www.delta1037.cn/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="https://www.delta1037.cn/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="SMS" scheme="https://www.delta1037.cn/tags/SMS/"/>
    
  </entry>
  
  <entry>
    <title>9.27~10.28计划</title>
    <link href="https://www.delta1037.cn/2017/Times/9.27~10.28%E8%AE%A1%E5%88%92/"/>
    <id>https://www.delta1037.cn/2017/Times/9.27~10.28%E8%AE%A1%E5%88%92/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2025-09-07T10:48:04.797Z</updated>
    
    <content type="html"><![CDATA[<p>9.27~10.28计划</p><span id="more"></span><h1 id="本月计划："><a href="#本月计划：" class="headerlink" title="本月计划："></a><strong>本月计划：</strong></h1><h3 id="9-27-10-1："><a href="#9-27-10-1：" class="headerlink" title="9.27-10.1："></a><strong>9.27-10.1：</strong></h3><p>1）学习机器学习算法–贝叶斯，向量机；学习对数据的处理 2）学习Python的基本语法结构，能够理解Python写的机器学习程序 3）算法导论学习29章线性规划</p><h3 id="10-1-10-7："><a href="#10-1-10-7：" class="headerlink" title="10.1-10.7："></a><strong>10.1-10.7：</strong></h3><p>1）完善多线程的知识结构，参考深入理解计算机系统的网络编程和并发编程，将socket服务端改写出一个多线程程序 2）算法导论30-31章多项式与快速傅里叶变换和数论算法，解决15-16章动态规划和贪心算法题目，理解红黑树删除部分 3）深入理解计算机系统复习第三章程序的程序级表示，学习第四章处理器体系结构，了解汇编语言内部原理 4）CTK+，改写计算器程序，有图形页面 5）解决ping解包错误问题 6）编译时自己写makefile和CMakeList.txt</p><h3 id="10-8-10-14："><a href="#10-8-10-14：" class="headerlink" title="10.8-10.14："></a><strong>10.8-10.14：</strong></h3><p>1）学习Linux系统管理 2）算法导论第32章字符串匹配，写23-24关于树的题目 3）深入理解计算机系统第五章-优化程序性能，写3-4章课后习题</p><h3 id="10-15-10-21："><a href="#10-15-10-21：" class="headerlink" title="10.15-10.21："></a><strong>10.15-10.21：</strong></h3><p>1）学习TCP&#x2F;IP 2）算法导论34章-NP完全性，写二叉树和红黑树题目 3）深入理解计算机系统第六章-存储器的层次结构，第五章课后习题</p><h3 id="10-22-10-28："><a href="#10-22-10-28：" class="headerlink" title="10.22-10.28："></a><strong>10.22-10.28：</strong></h3><p>1）继续学习shell脚本，完善知识体系的不足 2）算法导论35章-近似算法，写数论算法的题目 3）深入理解计算机系统第七章-链接，第六章课后习题</p><h3 id="总计划："><a href="#总计划：" class="headerlink" title="总计划："></a><strong>总计划：</strong></h3><p>每日一道leetcode，若easy则两道，以理解为主 <a href="http://www.geniusrabbit-liubo.top/">吾志所向,一往无前 愈挫愈勇,再接再厉</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;9.27~10.28计划&lt;/p&gt;</summary>
    
    
    
    <category term="时光" scheme="https://www.delta1037.cn/categories/%E6%97%B6%E5%85%89/"/>
    
    
    <category term="时光" scheme="https://www.delta1037.cn/tags/%E6%97%B6%E5%85%89/"/>
    
  </entry>
  
</feed>
